{
  "posts": [
    {
      "content": "单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。\r\n<!-- more -->\r\n## 1、产生背景\r\n单点登陆的产生主要是随着企业业务的发展，企业会有许多系统来处理不通的业务，而如果各个系统均单独做登陆认证功能，会造成多个系统都需要开发一样的认证逻辑的功能，而且用户在使用时也需要频繁的进行登陆退回，而单点登陆，就是多个系统共同信任同一份票据，这份票据，可以在各个业务系统中进行使用，以此来实现身份认证的组合。\r\n\r\n## 2、实现流程\r\n1、用户1登陆业务系统1\r\n2、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径1）\r\n3、用户没有登陆，跳转到登陆页面并携带（路径1）\r\n4、用户登陆，并保存凭据，重定向到（路径1），并携带凭据\r\n5、业务系统1 存储凭据\r\n6、用户2登陆业务系统2\r\n7、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径2）\r\n8、用户已登陆，重定向到（路径2），并携带凭据\r\n9、业务系统2，存储凭据\r\n\r\n## 3、客户端与服务器端的功能\r\n客户端：\r\n1、拦截子系统未登录用户请求，跳转至sso认证中心\r\n2、接收并存储sso认证中心发送的令牌\r\n3、与服务器端通信，校验令牌的有效性\r\n4、建立局部会话\r\n5、拦截用户注销请求，向sso认证中心发送注销请求\r\n服务器端：\r\n1、验证用户的登录信息\r\n2、创建全局会话\r\n3、创建授权令牌\r\n4、与客户端通信发送令牌\r\n6、校验客户端令牌有效性\r\n7、接收客户端注销请求，注销会话",
      "data": {
        "title": "单点登陆（SSO）介绍",
        "date": "2019-11-26 13:23:34",
        "tags": [
          "单点登陆"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/dan-dian-deng-lu-ssojie-shao.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。\r",
      "fileName": "dan-dian-deng-lu-ssojie-shao"
    },
    {
      "content": "\r\n密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。\r\n<!-- more -->\r\n# Shiro 密码加密\r\n\r\n## 0、前置代码:后面用到，以便理解\r\n```Java\r\n    /**\r\n     * 加密次数\r\n     */\r\n    Integer HASH_ITERATIONS=1024;\r\n    /**\r\n     * 加密算法\r\n     */\r\n    String HASH_ALGORITHMNAME=\"MD5\";\r\n```\r\n## 1、注册：注册和认证时密码需要用同样的策略，以保证密码密文的一致性。\r\n```Java\r\n    /**\r\n     * 注册\r\n     * @param registerVo\r\n     * @return\r\n     */\r\n    @PostMapping(\"/register\")\r\n    public ResultVo<Boolean> register(@RequestBody LoginRegisterVo registerVo){\r\n        //加密方式 可另行制定\r\n        String algorithmName= Constant.HASH_ALGORITHMNAME;\r\n        //密码明文\r\n        Object source=registerVo.getPassword();\r\n        //密码盐值 可另行制定\r\n        Object salt=registerVo.getUsername();\r\n        //加密次数 可另行制定\r\n        int hashIterations=Constant.HASH_ITERATIONS;\r\n        SimpleHash simpleHash = new SimpleHash(algorithmName, source, salt, hashIterations);\r\n        //加密后密码\r\n        String password = simpleHash.toHex();\r\n        log.info(password);\r\n        boolean flag=userService.addUser(registerVo.getUsername(),password);\r\n        if(!flag){\r\n            ResultVo.failure(Result.REGISTER_FAILURE);\r\n        }\r\n        return ResultVo.success(true);\r\n    }\r\n```\r\n根据以上注册可生成密码，那么在登陆的时候，该如何进行匹配呢？下面我来看一下登录如何进行\r\n## 2、认证：在进行用户认证(doGetAuthenticationInfo)时需要指定盐值，颜值需要唯一\r\n```Java\r\n    /**\r\n     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法\r\n     * @param authenticationToken 令牌\r\n     * @return 认证的信息\r\n     * @throws AuthenticationException 认证异常\r\n     */\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\r\n        log.info(\"开始进行身份认证！\");\r\n        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;\r\n        String username = usernamePasswordToken.getUsername();\r\n        User user = userService.getByUsername(username);\r\n        if(user==null){\r\n            log.info(\"用户未找到！\");\r\n            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());\r\n        }else if (Constant.USER_LOCKED.equals(user.getStatus())){\r\n            log.info(\"用户被锁定！\");\r\n            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());\r\n        }else {\r\n            Object principal=user.getId();\r\n            String credentials=user.getPassword();\r\n            String realmName=getName();\r\n            //指定盐值\r\n            ByteSource credentialsSalt = ByteSource.Util.bytes(usernamePasswordToken.getUsername());\r\n            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,credentialsSalt,realmName);\r\n            log.info(\"用户认证！\");\r\n            return simpleAuthenticationInfo;\r\n        }\r\n    }\r\n```\r\n## 3、配置Realm:在Realm密码策略以及加密次数\r\n```Java\r\n    /**\r\n     * 配置自定义的Realm\r\n     * @return CustomRealm\r\n     */\r\n    @Bean\r\n    public CustomRealm customRealm() {\r\n        CustomRealm customRealm = new CustomRealm();\r\n        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(Constant.HASH_ALGORITHMNAME);\r\n        credentialsMatcher.setHashIterations(Constant.HASH_ITERATIONS);\r\n        customRealm.setCredentialsMatcher(credentialsMatcher);\r\n        return customRealm;\r\n    }\r\n```\r\n## 4、扩展\r\n实际上Shiro支持多种密码策略，具体可以查看org.apache.shiro.authc.credential.CredentialsMatcher的子类\r\n# Shiro 会话管理\r\n## 1、使用当前会话\r\n```Java\r\n    SecurityUtils.getSubject().getSession();\r\n```\r\n## 2、会话管理器(SessionManager):管理session包括创建、维护、删除、失效、验证等工作。\r\n```Java\r\n/**\r\n * 自定义SessionManager:从请求头中也可获取JSESSIONID\r\n */\r\n@Slf4j\r\npublic class CustomWebSessionManager extends DefaultWebSessionManager{\r\n\r\n    private static final String JSESSIONID=\"JSESSIONID\";\r\n\r\n    @Override\r\n    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {\r\n        Serializable id = super.getSessionId(request,response);\r\n        //如果从Cookie中没有获取到SessionId,则从请求头中获取\r\n        if (id == null) {\r\n            id=WebUtils.toHttp(request).getHeader(JSESSIONID);\r\n        }\r\n        return id;\r\n    }\r\n}\r\n```\r\n## 3、会话监听器(SessionListener):监听会话状态，触发对应的方法\r\n```Java\r\n/**\r\n * 自定义SerssionListener 维护Session中的值\r\n */\r\npublic class CustomSessionListener implements SessionListener {\r\n    @Override\r\n    public void onStart(Session session) {\r\n        RedisUtil.set(session.getId().toString(),session);\r\n    }\r\n\r\n    @Override\r\n    public void onStop(Session session) {\r\n        RedisUtil.del(session.getId().toString());\r\n    }\r\n\r\n    @Override\r\n    public void onExpiration(Session session) {\r\n        RedisUtil.del(session.getId().toString());\r\n    }\r\n}\r\n```\r\n## 4、会话增删改查接口(SessionDAO)\r\n```Java\r\npublic interface SessionDAO {\r\n    Serializable create(Session var1);\r\n\r\n    Session readSession(Serializable var1) throws UnknownSessionException;\r\n\r\n    void update(Session var1) throws UnknownSessionException;\r\n\r\n    void delete(Session var1);\r\n\r\n    Collection<Session> getActiveSessions();\r\n}\r\n```\r\n",
      "data": {
        "title": "Shiro 密码加密与会话管理介绍",
        "date": "2019-11-14 23:54:05",
        "tags": [
          "Shiro"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/shiro-mi-ma-jia-mi.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\r\n密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。\r",
      "fileName": "shiro-mi-ma-jia-mi"
    },
    {
      "content": "前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。\r\n<!-- more -->\r\n## 1、实现权限认证逻辑\r\n基于前面的文章，自定义Realm继承AuthorizingRealm 需要实现doGetAuthenticationInfo 和 doGetAuthorizationInfo,其中doGetAuthenticationInfo主要用来身份认证，doGetAuthorizationInfo主要用来进行权限认证，具体代码如下：\r\n前置代码：\r\n```Java\r\n    private static final Map<String,Set<String>> USER_ROLE= new HashMap<>();\r\n    static {\r\n        USER_ROLE.put(\"1\",new HashSet<>(Arrays.asList(\"item:add\",\"item:search\",\"item:update\",\"item:delete\")));\r\n        USER_ROLE.put(\"2\",new HashSet<>(Arrays.asList(\"item:add\",\"item:search\")));\r\n    }\r\n\r\n    @Override\r\n    public Set<String> getUserRoles(String userId) {\r\n        Set<String> result = USER_ROLE.get(userId);\r\n        return result!=null?result:Collections.EMPTY_SET;\r\n    }\r\n```\r\n```Java\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        log.info(\"开始进行权限认证！\");\r\n        SimpleAuthorizationInfo simpleAuthorizationInfo=new SimpleAuthorizationInfo();\r\n        String userId = (String)principalCollection.getPrimaryPrincipal();\r\n        Set<String> userRoles = roleService.getUserRoles(userId);\r\n        for (String userRole:userRoles){\r\n            simpleAuthorizationInfo.addStringPermission(userRole);\r\n        }\r\n        return simpleAuthorizationInfo;\r\n    }\r\n```\r\n## 2、配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor\r\n因为Shiro需要对Controller进行代理，所以需要开启Controller的代理，需要配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor\r\n```Java\r\n    @Bean\r\n    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor(){\r\n        return new LifecycleBeanPostProcessor();\r\n    }\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator(){\r\n        DefaultAdvisorAutoProxyCreator creator=new DefaultAdvisorAutoProxyCreator();\r\n        creator.setProxyTargetClass(true);\r\n        return creator;\r\n    }\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor advisor=new AuthorizationAttributeSourceAdvisor();\r\n        advisor.setSecurityManager(securityManager);\r\n        return advisor;\r\n    }\r\n```\r\n## 3、配置请求权限码\r\n通过注解配置权限信息，@RequiresRoles、@RequiresPermissions 以@RequiresPermissions为例：\r\n```Java\r\n    @RequiresPermissions(\"item:search\")\r\n    @GetMapping(\"/search\")\r\n    public ResultVo<String> search(){\r\n        return ResultVo.success(\"search\");\r\n    }\r\n    @RequiresPermissions(\"item:add\")\r\n    @GetMapping(\"/add\")\r\n    public ResultVo<String> add(){\r\n        return ResultVo.success(\"add\");\r\n    }\r\n    @RequiresPermissions(\"item:update\")\r\n    @GetMapping(\"/update\")\r\n    public ResultVo<String> update(){\r\n        return ResultVo.success(\"update\");\r\n    }\r\n    @RequiresPermissions(\"item:delete\")\r\n    @GetMapping(\"/delete\")\r\n    public ResultVo<String> delete(){\r\n        return ResultVo.success(\"delete\");\r\n    }\r\n```\r\n## 4、演示效果\r\n用户登陆：\r\n![登陆用户](https://bofengsun.github.io//post-images/1573745823357.png)\r\n有权限：\r\n![有权限](https://bofengsun.github.io//post-images/1573745976892.png)\r\n无权限：\r\n![无权限](https://bofengsun.github.io//post-images/1573746081151.png)",
      "data": {
        "title": "Shiro 权限认证",
        "date": "2019-11-13 12:39:28",
        "tags": [
          "Shiro"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/shiro-quan-xian-ren-zheng.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。\r",
      "fileName": "shiro-quan-xian-ren-zheng"
    },
    {
      "content": "Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。\r\n<!-- more -->\r\n## Jmeter 介绍\r\nApache JMeter 是一款开源的Java开发的用于进行软件性能测试的软件。\r\n## 安装和运行\r\n下载地址：http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-5.2.zip\r\n运行：windows环境： “bin/jmeter.bat”   linux环境： “bin/jmeter.sh”   \r\n切换语言： 启动Jmeter 后， 点击 Options -> Choose Language -> Chinese[Simplified]  来选择简体中文\r\n截图如下：\r\n![Jmeter](https://bofengsun.github.io//post-images/1573559262706.png)\r\n## 案例\r\n### 添加默认设置\r\n1、添加 HTTP Cookie管理器\r\n![HTTP Cookie管理器](https://bofengsun.github.io//post-images/1573563560952.png)\r\n2、添加 默认请求头\r\n![默认请求头](https://bofengsun.github.io//post-images/1573563633762.png)\r\n3、添加 默认请求\r\n![默认请求](https://bofengsun.github.io//post-images/1573563677239.png)\r\n### 添加线程组\r\n参数说明：\r\n    线程数：表示需要启动的线程数量\r\n    Ramp-Up时间：多少秒内启动这些线程，也就是说会在这个时间内启动这么多线程，如果设置为0，则表示同时启动\r\n    循环次数：表示重复运行多少次，永远表示一直重复直到时间结束\r\n    调度器配置：在配置调度器时生效，持续时间：就是执行多久\r\n![添加线程组](https://bofengsun.github.io//post-images/1573563731549.png)\r\n### 添加定时器\r\n![添加定时器](https://bofengsun.github.io//post-images/1573609185253.png)\r\n### 添加事务控制器\r\n![事务控制器](https://bofengsun.github.io//post-images/1573563817861.png)\r\n### 添加请求\r\n![添加请求](https://bofengsun.github.io//post-images/1573609251077.png)\r\n### 添加断言\r\n![添加断言](https://bofengsun.github.io//post-images/1573609303540.png)\r\n### 添加查看结果树\r\n![添加查看结果树](https://bofengsun.github.io//post-images/1573609390929.png)\r\n### 添加聚合报告\r\n![添加聚合报告](https://bofengsun.github.io//post-images/1573609486454.png)\r\n",
      "data": {
        "title": "Jmeter 体验之旅",
        "date": "2019-11-12 19:23:40",
        "tags": [
          "Jmeter"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/jmeter-ti-yan-zhi-lu.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。\r",
      "fileName": "jmeter-ti-yan-zhi-lu"
    },
    {
      "content": "上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。\r\n<!-- more -->\r\n## 一、如何和支持WEB、APP、以及其他方式进行身份认证？\r\n先回顾一下上一节我们的登陆部分代码：\r\n```Java\r\n/**\r\n * 认证控制器\r\n */\r\n@RestController\r\n@RequestMapping(\"/auth\")\r\n@Slf4j\r\npublic class AuthController {\r\n\r\n    /**\r\n     * 登陆\r\n     * @param username 用户名\r\n     * @param password 密码\r\n     * @return 登陆结果\r\n     */\r\n    @PostMapping(\"/login\")\r\n    public ResultVo<String> login(@RequestParam(\"username\") String username,@RequestParam(\"password\") String password){\r\n        Subject currentUser = SecurityUtils.getSubject();\r\n        if (!currentUser.isAuthenticated()) {\r\n            UsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n            try {\r\n                currentUser.login(token);\r\n                return ResultVo.success(currentUser.getSession().getId().toString());\r\n            }catch (LockedAccountException lae) {\r\n                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);\r\n            }\r\n            catch (AuthenticationException ae) {\r\n                return ResultVo.failure(Result.LOGIN_FAILURE);\r\n            }\r\n        }else {\r\n            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);\r\n        }\r\n    }\r\n}\r\n```\r\n可以看到我们在登陆成功后，把用户的SessionId返回给客户端，但在传统WEB其实是不需要的，因为在认证成功后会将SessionId保存在cookie里JSESSIONID，那么如果我们需要兼容APP或者其他方式这样就行不通，一种比较简单的方式就是我们把SessionId返回给客户端，客户端保存一份，每次请求时，将其作为请求头请求服务端，同时服务端也要改变获取SessionId的方式，不是从cookie里获取，而是从header里获取，这样就可以解决该问题，那么下面我们就看一下在Shiro中该如何做吧。\r\n1、自定义SessionManager继承DefaultWebSessionManager\r\n```Java\r\n/**\r\n * 自定义SessionManager\r\n */\r\n@Slf4j\r\npublic class CustomWebSessionManager extends DefaultWebSessionManager{\r\n\r\n    private static final String JSESSIONID=\"JSESSIONID\";\r\n\r\n    @Override\r\n    public Serializable getSessionId(SessionKey key) {\r\n        Serializable id = super.getSessionId(key);\r\n        //如果从Cookie中没有获取到SessionId,则从请求头中获取\r\n        if (id == null) {\r\n            HttpServletRequest request = (HttpServletRequest)WebUtils.getRequest(key);\r\n            id = request.getHeader(JSESSIONID);\r\n        }\r\n        return id;\r\n    }\r\n}\r\n```\r\n2、将自定义的SessionManager放入容器中\r\n3、设置SecurityManager的SessionManager为自定义的SessionManager\r\n```Java\r\n/**\r\n * Shiro 配置\r\n */\r\n@Configuration\r\npublic class ShiroConfig {\r\n\r\n    /**\r\n     * 配置ShiroFilter\r\n     * @param securityManager 注入SecurityManager\r\n     * @return ShiroFilterFactoryBean\r\n     */\r\n    @Bean(name = \"shiroFilter\")\r\n    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\r\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\r\n        Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();\r\n        filterChainDefinitionMap.put(\"/auth/login\", \"anon\");\r\n        filterChainDefinitionMap.put(\"/openapi/**\", \"anon\");\r\n        filterChainDefinitionMap.put(\"/**\", \"authc\");\r\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\r\n        return shiroFilterFactoryBean;\r\n    }\r\n\r\n    /**\r\n     * 配置SecurityManager\r\n     * @param customRealm 注入自定义Realm\r\n     * @return SecurityManager\r\n     */\r\n    @Bean\r\n    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\r\n        defaultSecurityManager.setSessionManager(sessionManager);\r\n        defaultSecurityManager.setRealm(customRealm);\r\n        return defaultSecurityManager;\r\n    }\r\n\r\n    /**\r\n     * 配置自定义SessionManager\r\n     * @return\r\n     */\r\n    @Bean(\"sessionManager\")\r\n    public CustomWebSessionManager customWebSessionManager(){\r\n        return new CustomWebSessionManager();\r\n    }\r\n\r\n    /**\r\n     * 配置自定义的Realm\r\n     * @return CustomRealm\r\n     */\r\n    @Bean\r\n    public CustomRealm customRealm() {\r\n        CustomRealm customRealm = new CustomRealm();\r\n        return customRealm;\r\n    }\r\n}\r\n```\r\n4、客户端登陆成功后将sessionId保存起来，每次请求的时候带上该请求头\r\n## 二、分布式环境下，如何来维护Session的呢？\r\n那么这里就是如何统一维护Session的问题了，我们一般会将Session保存在缓存中间件里，例如Redis，这样即保证性能，又实现功能，下面我们就体验一下吧？\r\n1、连接Redis以及编写RedisUtil（该部分仍是采用MAP进行处理，待后面和Redis继承时修改这里）\r\n```Java\r\n/**\r\n * Redis工具类\r\n */\r\npublic class RedisUtil {\r\n    static Map<String,Object> SESSION_ID_CACHE=new HashMap<>();\r\n    public static void set(String key,Object value){\r\n        SESSION_ID_CACHE.put(key,value);\r\n    }\r\n    public static Object get(String key){\r\n        return SESSION_ID_CACHE.get(key);\r\n    }\r\n    public static void del(String key){\r\n        SESSION_ID_CACHE.remove(key);\r\n    }\r\n    public static Collection values(){\r\n        return SESSION_ID_CACHE.values();\r\n    }\r\n}\r\n```\r\n2、编写自定义SessionDao 继承EnterpriseCacheSessionDAO 重写读取Session的方法\r\n```Java\r\n/**\r\n * 自定义SessionDAO从Redis中读取Session\r\n */\r\npublic class CustomSessionDAO extends EnterpriseCacheSessionDAO {\r\n    @Override\r\n    protected Session doReadSession(Serializable serializable) {\r\n        return (Session) RedisUtil.get(serializable.toString());\r\n    }\r\n}\r\n```\r\n3、编写自定义SerssionListener 维护Session中的值\r\n```Java\r\n/**\r\n * 自定义SerssionListener 维护Session中的值\r\n */\r\npublic class CustomSessionListener implements SessionListener {\r\n    @Override\r\n    public void onStart(Session session) {\r\n        RedisUtil.set(session.getId().toString(),session);\r\n    }\r\n\r\n    @Override\r\n    public void onStop(Session session) {\r\n        RedisUtil.del(session.getId().toString());\r\n    }\r\n\r\n    @Override\r\n    public void onExpiration(Session session) {\r\n        RedisUtil.del(session.getId().toString());\r\n    }\r\n}\r\n\r\n```\r\n3、将CustomSessionDAO、CustomSerssionListener加入Shiro配置中\r\n```Java\r\n/**\r\n * Shiro 配置\r\n */\r\n@Configuration\r\npublic class ShiroConfig {\r\n\r\n    /**\r\n     * 配置ShiroFilter\r\n     * @param securityManager 注入SecurityManager\r\n     * @return ShiroFilterFactoryBean\r\n     */\r\n    @Bean(name = \"shiroFilter\")\r\n    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\r\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\r\n        Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();\r\n        filterChainDefinitionMap.put(\"/auth/login\", \"anon\");\r\n        filterChainDefinitionMap.put(\"/openapi/**\", \"anon\");\r\n        filterChainDefinitionMap.put(\"/**\", \"authc\");\r\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\r\n        return shiroFilterFactoryBean;\r\n    }\r\n\r\n    /**\r\n     * 配置SecurityManager\r\n     * @param customRealm 注入自定义Realm\r\n     * @return SecurityManager\r\n     */\r\n    @Bean\r\n    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\r\n        defaultSecurityManager.setSessionManager(sessionManager);\r\n        defaultSecurityManager.setRealm(customRealm);\r\n        return defaultSecurityManager;\r\n    }\r\n\r\n    /**\r\n     * 配置自定义SessionManager\r\n     * @return\r\n     */\r\n    @Bean(\"sessionManager\")\r\n    public CustomWebSessionManager customWebSessionManager(SessionDAO sessionDAO){\r\n        CustomWebSessionManager customWebSessionManager=new CustomWebSessionManager();\r\n        customWebSessionManager.setSessionDAO(sessionDAO);\r\n        //配置自定义\r\n        List<SessionListener> listeners=new ArrayList<>();\r\n        listeners.add(new CustomSessionListener());\r\n        customWebSessionManager.setSessionListeners(listeners);\r\n        return customWebSessionManager;\r\n    }\r\n\r\n    /**\r\n     * 配置自定义的Realm\r\n     * @return CustomRealm\r\n     */\r\n    @Bean\r\n    public CustomRealm customRealm() {\r\n        CustomRealm customRealm = new CustomRealm();\r\n        return customRealm;\r\n    }\r\n\r\n    /**\r\n     * 配置自定义SessionDAO\r\n     * @return CustomSessionDAO\r\n     */\r\n    @Bean(\"sessionDAO\")\r\n    public CustomSessionDAO customSessionDao(){\r\n        CustomSessionDAO customSessionDAO=new CustomSessionDAO();\r\n        customSessionDAO.setSessionIdGenerator(new JavaUuidSessionIdGenerator());\r\n        return customSessionDAO;\r\n    }\r\n}\r\n```\r\n## 三、基于Token的验证方式\r\n现如今，很多Web应用的验证方式都会采用基于token的验证方式，实际上这种方式很像我们上面所说的将SessionId放入请求头中，只是基于token的这种方式，token的保存的信息可能更具有意义。那在Shiro中如何来实现呢？\r\n1、登陆成功时，生成对应的token,并保存在redis中\r\n2、编写认证服务器,继承FormAuthenticationFilter,并重写onAccessDenied，从请求头中获取获取TOKEN，并从redis中获取token，对比token即可。\r\n## 四、统一认证中心\r\n统一认证中心主要是进行统一的身份认证，主要是以下几个步骤：\r\n1、请求认证中心时，需要将验证后需要跳转的URL作为请求参数；\r\n2、服务端修改为不仅可以从Cookie和Header中获取对应的token或者sessionId，还需要可以从请求参数里获取到对应的值；\r\n3、服务端认证成功后将token或者sessionId作为参数重定向到登陆认证的回调地址。",
      "data": {
        "title": "Shiro 身份认证（续）",
        "date": "2019-11-11 13:25:45",
        "tags": [
          "Shiro"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/shiro-authentication-2.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。\r",
      "fileName": "shiro-authentication-2"
    },
    {
      "content": "\r\n上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。\r\n<!-- more -->\r\n在上一节中我们看到Shiro的登陆，当时的用户信息是在配置文件中，但在实际项目中并不会这样，而是存储在数据库中那么，这种情况下Shiro又是怎样进行身份认证的呢？我们对上一章的代码做一个简单的修改，以了解认证的过程：\r\n依赖包：\r\n```XML\r\n<dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <version>1.18.8</version>\r\n        </dependency>\r\n        <!--整合Shiro-->\r\n        <dependency>\r\n            <groupId>org.apache.shiro</groupId>\r\n            <artifactId>shiro-spring</artifactId>\r\n            <version>1.4.0</version>\r\n        </dependency>\r\n    </dependencies>\r\n```\r\n前置代码：\r\n```Java\r\n/**\r\n * 统一维护返回的数据\r\n */\r\npublic enum Result{\r\n    //默认返回数据\r\n    SUCCESS(0,\"请求成功！\"),\r\n    FAILURE(500,\"请求失败！\"),\r\n    //认证授权部分\r\n    LOGIN_FAILURE(501,\"用户名或者密码错误！\"),\r\n    LOGIN_FAILURE_LOCK(501,\"用户被锁定,请联系管理员！\"),\r\n    LOGIN_FAILURE_RELOGIN(502,\"用户已经登陆,无须再次登陆！\"),\r\n    AUTH_FAILURE(511,\"无权限！\");\r\n\r\n    private Integer code;\r\n    private String msg;\r\n    private Result(Integer code,String msg){\r\n        this.code=code;\r\n        this.msg=msg;\r\n    }\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n    public String getMsg() {\r\n        return msg;\r\n    }\r\n}\r\n/**\r\n * 统一返回的数据类型\r\n */\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class ResultVo<T> {\r\n    private Integer code;\r\n    private String msg;\r\n    private T data;\r\n    public static <T> ResultVo<T> success(T data){\r\n        return new ResultVo<>(Result.SUCCESS.getCode(),Result.SUCCESS.getMsg(),data);\r\n    }\r\n    public static<T> ResultVo<T> failure(Result result){\r\n        return new ResultVo<>(result.getCode(),result.getMsg(),null);\r\n    }\r\n}\r\n```\r\nShiro的配置：Realm、SecurityManager、shiroFilter\r\n- Relam:安全数据\r\n- SecurityManager： Shiro 的大管家负责组件协调\r\n- shiroFilter： Filter对哪些请求进行拦截\r\n```Java\r\n/**\r\n * Shiro 配置\r\n */\r\n@Configuration\r\npublic class ShiroConfig {\r\n\r\n    /**\r\n     * 配置ShiroFilter\r\n     * @param securityManager 注入SecurityManager\r\n     * @return ShiroFilterFactoryBean\r\n     */\r\n    @Bean(name = \"shiroFilter\")\r\n    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\r\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\r\n        Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();\r\n        filterChainDefinitionMap.put(\"/auth/login\", \"anon\");\r\n        filterChainDefinitionMap.put(\"/**\", \"authc\");\r\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\r\n        return shiroFilterFactoryBean;\r\n    }\r\n\r\n    /**\r\n     * 配置SecurityManager\r\n     * @param customRealm 注入自定义Realm\r\n     * @return SecurityManager\r\n     */\r\n    @Bean\r\n    public SecurityManager securityManager(CustomRealm customRealm) {\r\n        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\r\n        defaultSecurityManager.setRealm(customRealm);\r\n        return defaultSecurityManager;\r\n    }\r\n\r\n    /**\r\n     * 配置自定义的Realm\r\n     * @return CustomRealm\r\n     */\r\n    @Bean\r\n    public CustomRealm customRealm() {\r\n        CustomRealm customRealm = new CustomRealm();\r\n        return customRealm;\r\n    }\r\n}\r\n```\r\n\r\n登陆认证部分的代码：\r\n```Java\r\n/**\r\n * 认证控制器\r\n */\r\n@RestController\r\n@RequestMapping(\"/auth\")\r\n@Slf4j\r\npublic class AuthController {\r\n\r\n    /**\r\n     * 登陆\r\n     * @param username 用户名\r\n     * @param password 密码\r\n     * @return 登陆结果\r\n     */\r\n    @PostMapping(\"/login\")\r\n    public ResultVo<String> login(@RequestParam(\"username\") String username,@RequestParam(\"password\") String password){\r\n        Subject currentUser = SecurityUtils.getSubject();\r\n        if (!currentUser.isAuthenticated()) {\r\n            UsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n            try {\r\n                currentUser.login(token);\r\n                return ResultVo.success(currentUser.getSession().getId().toString());\r\n            }catch (LockedAccountException lae) {\r\n                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);\r\n            }\r\n            catch (AuthenticationException ae) {\r\n                return ResultVo.failure(Result.LOGIN_FAILURE);\r\n            }\r\n        }else {\r\n            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);\r\n        }\r\n    }\r\n}\r\n```\r\n流程分析：\r\n1、先通过SecurityUtils#getSubject()获取当前用户\r\n2、Subject#isAuthenticated()调用判断当前用户是否登陆\r\n3、若没用进行登陆认证，则将用户的username和password为封装UsernamePasswordToken\r\n4、调用Subject#login(token)进行登陆\r\n5、通过自定义Realm进行身份认证，自定义Realm如果只是用来进行身份认证则只需继承org.apache.shiro.realm.AuthenticatingRealm即可，如果还需要进行鉴权，则需要继承org.apache.shiro.realm.AuthorizingRealm,这里我们就先继承AuthenticatingRealm。\r\n查看Realm的前置代码：\r\n```Java\r\n/**\r\n * 用户实体信息\r\n */\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Builder\r\npublic class User {\r\n\r\n    /**\r\n     * 逻辑ID\r\n     */\r\n    private String id;\r\n    /**\r\n     * 用户名(唯一)\r\n     */\r\n    private String username;\r\n    /**\r\n     * 密码\r\n     */\r\n    private String password;\r\n    /**\r\n     * 状态是否锁定:1 是；0否\r\n     */\r\n    private Integer status;\r\n}\r\n/**\r\n * 用户服务\r\n */\r\npublic interface UserService {\r\n    /**\r\n     * 根据用户名获取用户\r\n     * @param username 用户名\r\n     * @return User\r\n     */\r\n    User getByUsername(String username);\r\n}\r\n@Service\r\npublic class UserServiceImpl implements UserService {\r\n    /**\r\n     * 初始化用户数据源\r\n     */\r\n    static final Map<String,User> USERS = new HashMap<>();\r\n    static {\r\n        USERS.put(\"admin\",User.builder()\r\n                .id(\"1\")\r\n                .username(\"admin\")\r\n                .password(\"123456\")\r\n                .status(0)\r\n                .build());\r\n        USERS.put(\"guest\",User.builder()\r\n                .id(\"2\")\r\n                .username(\"guest\")\r\n                .password(\"123456\")\r\n                .status(0)\r\n                .build());\r\n        USERS.put(\"lockeduser\",User.builder()\r\n                .id(\"2\")\r\n                .username(\"lockeduser\")\r\n                .password(\"123456\")\r\n                .status(1)\r\n                .build());\r\n    }\r\n\r\n    @Override\r\n    public User getByUsername(String username) {\r\n        return USERS.get(username);\r\n    }\r\n}\r\n/**\r\n * 常量类\r\n */\r\npublic interface Constant {\r\n    /**\r\n     * 用户被锁定状态\r\n     */\r\n    Integer USER_LOCKED=1;\r\n}\r\n/**\r\n * 自定义Realm\r\n */\r\n@Slf4j\r\npublic class CustomRealm extends AuthenticatingRealm {\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    /**\r\n     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法\r\n     * @param authenticationToken 令牌\r\n     * @return 认证的信息\r\n     * @throws AuthenticationException 认证异常\r\n     */\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\r\n        log.info(\"开始进行身份认证！\");\r\n        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;\r\n        String username = usernamePasswordToken.getUsername();\r\n        User user = userService.getByUsername(username);\r\n        if(user==null){\r\n            log.info(\"用户未找到！\");\r\n            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());\r\n        }else if (Constant.USER_LOCKED.equals(user.getStatus())){\r\n            log.info(\"用户被锁定！\");\r\n            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());\r\n        }else {\r\n            String principal=username;\r\n            String credentials=user.getPassword();\r\n            String realmName=getName();\r\n            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,realmName);\r\n            log.info(\"认证成功！\");\r\n            return simpleAuthenticationInfo;\r\n        }\r\n    }\r\n}\r\n```\r\n",
      "data": {
        "title": "Shiro 身份认证",
        "date": "2019-11-10 18:57:42",
        "tags": [
          "Shiro"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/shiro-authentication.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\r\n上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。\r",
      "fileName": "shiro-authentication"
    },
    {
      "content": "Shiro 是一个Java安全框架，主要是进行身份认证，权限认证，密码加密，会话管理的一套框架，下面让我们一起来认识一下Shiro吧!\r\n<!-- more -->\r\n## 1、认识Shiro的功能\r\n看图说话，下图中是Shiro官网给出的描述，很明显主要包括四点：\r\n- Authentication(身份认证)\r\n- Authorization(权限认证)\r\n- Session Management(会话管理)\r\n- Cryptography(密码学)\r\n![Shiro功能](https://bofengsun.github.io//post-images/1573123546063.png)\r\n\r\n## 2、关键概念认识\r\n- Subject (org.apache.shiro.subject.Subject) 主体\r\n  指正在访问的主体，通常指当前用户，亦可指爬虫、定时任务等。\r\n- SecurityManager (org.apache.shiro.mgt.SecurityManager) 安全管理器\r\n  安全管理器，是Shiro的核心，管理着所有的Subject，负责与Shiro的其他组件进行交互，类似与SpringMvc 中的DispatcherServlet。\r\n- Realms 安全数据\r\n  主要是储存Shiro的安全数据（用户、角色、权限等），SecurityManager验证用户是否登陆、是否拥有权限等需要从其中获取数据。\r\n![](https://bofengsun.github.io//post-images/1573126718187.png)\r\n## 3、初体验\r\n```Java\r\n//git clone https://github.com/apache/shiro.git 下载Shiro源码包括该代码。\r\n\r\npublic class Quickstart {\r\n\r\n    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);\r\n\r\n\r\n    public static void main(String[] args) {\r\n\r\n        //用来从配置文件初始化Shiro环境，一般不会用\r\n        Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\r\n        SecurityManager securityManager = factory.getInstance();\r\n        SecurityUtils.setSecurityManager(securityManager);\r\n        //获取当前用户,从这以后的代码都比较重要\r\n        Subject currentUser = SecurityUtils.getSubject();\r\n        //获取Session\r\n        Session session = currentUser.getSession();\r\n        session.setAttribute(\"someKey\", \"aValue\");\r\n        String value = (String) session.getAttribute(\"someKey\");\r\n        if (value.equals(\"aValue\")) {\r\n            log.info(\"Retrieved the correct value! [\" + value + \"]\");\r\n        }\r\n\r\n        // 判断用户是否经过身份认证，如果没用则进行身份认证\r\n        if (!currentUser.isAuthenticated()) {\r\n            //通过用户名密码进行登陆\r\n            UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\");   //设置记住我\r\n            token.setRememberMe(true);\r\n            try {\r\n                //进行登陆\r\n                currentUser.login(token);\r\n            } catch (UnknownAccountException uae) {//用户不存在异常\r\n                log.info(\"There is no user with username of \" + token.getPrincipal());\r\n            } catch (IncorrectCredentialsException ice) {//密码不正确异常\r\n                log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\");\r\n            } catch (LockedAccountException lae) {//用户被锁定异常\r\n                log.info(\"The account for username \" + token.getPrincipal() + \" is locked.  \" +\r\n                        \"Please contact your administrator to unlock it.\");\r\n            }\r\n            // ... catch more exceptions here (maybe custom ones specific to your application?\r\n            catch (AuthenticationException ae) {//认证异常，查看其子类发现Shiro提供的认证异常\r\n                //unexpected condition?  error?\r\n            }\r\n        }\r\n\r\n        log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\");\r\n\r\n        // 判断用户是否拥有角色\r\n        if (currentUser.hasRole(\"schwartz\")) {\r\n            log.info(\"May the Schwartz be with you!\");\r\n        } else {\r\n            log.info(\"Hello, mere mortal.\");\r\n        }\r\n\r\n        //判断用户是否拥有权限\r\n        //判断用户是否拥有winnebago:drive:eagle5权限\r\n        //winnebago 类型，driver 行为，eagle5对象\r\n        //如 当前用户拥有对张三（对象）这个用户（类型）的删除行为\r\n        if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) {\r\n            log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  \" +\r\n                    \"Here are the keys - have fun!\");\r\n        } else {\r\n            log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\");\r\n        }\r\n\r\n        //用户退出登陆\r\n        currentUser.logout();\r\n\r\n        System.exit(0);\r\n    }\r\n}\r\n```",
      "data": {
        "title": "Shiro 初体验",
        "date": "2019-11-08 17:39:44",
        "tags": [
          "Shiro"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/shiro-01.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "Shiro 是一个Java安全框架，主要是进行身份认证，权限认证，密码加密，会话管理的一套框架，下面让我们一起来认识一下Shiro吧!\r",
      "fileName": "shiro-01"
    },
    {
      "content": "万丈高楼平地起，掌握并牢记基础知识，是学习后面知识的根基，下面我们一起回顾一下Java的基础知识吧！\r\n<!-- more -->\r\n\r\n## 一、基础部分\r\n\r\n### 1、基本数据类型8中\r\n\r\n```JAVA\r\n四种整数型：byte(8)、short(16)、int(32)、long(64)\r\n\r\n二种浮点型：float(32)、double(64)\r\n\r\n一种字符型：char(16)\r\n\r\n一种布尔型：boolean\r\n```\r\n\r\n### 2、Object类常用方法\r\n\r\n```java\r\nEquals\r\nHashcode\r\ntoString\r\nwait\r\nnotify\r\nnotifyAll\r\nclone\r\ngetClass\r\nfinalize\r\n```\r\n\r\n### 3、值传递、引用传递\r\n\r\nJava中是值传递，对于基本数据类型，传递的是值的副本，对于引用类型传递的是对象地址的副本。\r\n\r\n```java\r\npackage com.itbofeng;\r\n\r\npublic class TestValuePassRefPass {\r\n    public static void main(String[] args) {\r\n        int i=100;\r\n        String str=\"aa\";\r\n        changeInt(i);\r\n        changeString(str);\r\n        System.out.println(i);//100\r\n        System.out.println(str);//aa\r\n    }\r\n    private static void changeInt(int i) {\r\n        i=0;\r\n    }\r\n    private static void changeString(String str) {\r\n        str=\"bb\";\r\n    }\r\n}\r\n```\r\n\r\n### 4、数组实例化\r\n\r\n```JAVA\r\n1、数组一旦实例化，它的长度就是固定的\r\n\r\n2、静态实例化:```java int[] a=new int[]{1,3,3}``` , ```java int[] a={1,3,3}```\r\n   动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值\r\n\r\n3、数组反序\r\n  1、将原数组中的元素进行逆序（原数组改变，占用内存小）\r\n  public void arrayReverse() {\r\n        int []originArray={1,2,3,4,5}\r\n        int temp = 0;\r\n        for (int i = 0; i < length / 2; i++) {\r\n            temp = originArray[i];\r\n            originArray[i] = originArray[length - i - 1];\r\n            originArray[length - i - 1] = temp;\r\n        }\r\n  }\r\n  2、创建新数组逆序存储原数组元素（原数组不变，占用内存大）\r\n  public void arrayReverse() {\r\n        int []originArray={1,2,3,4,5}\r\n        int length=originArray.length;\r\n        int []reverseArray = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            reverseArray[i] = originArray[length - i - 1];\r\n        }\r\n  }\r\n```\r\n\r\n### 5、&和&&的区别 、|和||的区别 \r\n\r\n```java\r\n\t&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。\r\n\t&&具有短路的功能,&不具备短路的功能\r\n\t|和||都可以用作逻辑或的运算符，表示逻辑或（or），当运算符两边的表达式的结果有一个为true时，整个运算结果才为true，否则，只有全部为false，则结果为false。\r\n\t||具有短路的功能,|不具备短路的功能\r\n```\r\n\r\n### 6、String和StringBuilder，StringBuffer的区别\r\n\r\n```Java\r\n\t1、String对象不可变，因此在进⾏任何内容上的修改时都会创建新的字符串对象，修改操作太多造成资源浪费。\r\n    2、StringBuilder和StringBuffer修改字符串不是创建新的对象，而是在原对象上面进行修改。\r\n    3、StringBuffer线程安全的是 StringBuilder是线程不安全的，StringBuilder效率比StringBuffer高。\r\n```\r\n\r\n### 7、HashMap、HashTable、 ConcurrentHashMap 的区别\r\n\r\n```Java\r\n    1、HashMap不是线程安全的、HashTable、ConcurrentHashMap是线程安全的。\r\n    2、HashTable是synchronized锁定方法，在高并发环境下效率比较低，ConcurrentHashMap采用分段锁，从而增加并发性能。\r\n    备注：在源码讲解中会分别对HashMap、HashTable、ConcurrentHashMap进行讲解。\r\n```\r\n\r\n### 8、switch 语法\r\n\r\n```java\r\n    1、在switch（exp）中，exp只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的\r\n    2、从Java SE 7开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。\r\n    3、Long、Double不支持 非整数表达式或者枚举常量以及字符串\r\n```\r\n\r\n### 9、大数计算思路\r\n\r\n```java\r\n\t考点：\r\n        1、计算机原理\r\n        2、计算机中的算术运算会发生越界的情况\r\n        3、具备一定的面向对象的设计思想\r\n    思路：\r\n        1、计算机原理（原码、反码、补码）\r\n        2、面向对象设计\r\n    实现：\r\n        1、这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数\r\n        2、有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中\r\n        3、提供加减乘除的功能\r\n    代码：\r\n        public class BigInteger{\r\n            byte sign;\r\n            byte[] val;\r\n            public Biginteger(String val)\t{\r\n                sign =a ;\r\n                val = ;\r\n            }\r\n            public BigInteger add(BigInteger other)\t{\r\n\r\n            }\r\n            public BigInteger subtract(BigInteger other)\t{\r\n\r\n            }\r\n            public BigInteger multiply(BigInteger other){\r\n\r\n            }\r\n            public BigInteger divide(BigInteger other){\r\n\r\n            }\r\n        }\r\n\r\n```\r\n\r\n### 10、\"==\"和equals方法  \r\n\r\n```java\r\n\t1、对于引用类型，涉及了两块内存，对象本身占用一块内存（堆），变量也占用一块内存（栈），例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。\r\n\t2、==\r\n      ==操作符专门用来比较基本数据类型的值是否相等，以及引用类型的变量地址是否相等，即比较栈中值是否相等\r\n    3、equals\r\n      equals方法是Java Object类中的方法，在Object类中equals的实现是等同于==，如果一个对象没有重写equals方法，那么此时equals方法等同于==，但是在许多对象比较中，例如字符串，我们实际需要比较的对象的值是否相等，而不是变量的值是否相等，那么此时需要重写equals\r\n```\r\n\r\n### 11、基本数据类型和包装类型的区别\r\n\r\n```Java\r\n    1、基本类型和包装类型的默认值不同，基本类型有自己的默认值，包装类型默认值是null\r\n    2、基本类型==比较的是值，包装类型==比较的是变量地址\r\n    3、包装类型提供了很多其他的方法\r\n```\r\n\r\n### 12、作用域public，private，protected，以及不写时（friendly）区别  \r\n\r\n|  作用域    | 当前类  | 同一包  | 子孙类  | 其他包  |\r\n| :-------: | :----: | :----: | :----: | :----: |\r\n|  public   |   √    |   √    |   √    |   √    |\r\n| protected |   √    |   √    |   √    |   ×    |\r\n| friendly  |   √    |   √    |   ×    |   ×    |\r\n|  private  |   √    |   ×    |   ×    |   ×    |\r\n\r\n### 13、静态变量和实例变量的区别  \r\n\r\n```Java\r\n    1、在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加\r\n    2、在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。\r\n```\r\n\r\n### 14、重载(Overload)&重写（Override）\r\n\r\n```JAVA\r\n    1、重载：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\r\n    2、重写：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。\r\n```\r\n\r\n### 15、continue &  break \r\n\r\n```JAVA\r\n    1、continue:在循环语句中,它会中断正常的控制流程，跳出当次循环,然后继续下一次循环；\r\n    2、break：可用在循环,判断等语句中,用于退出当前语句，在循环语句中就是退出当前循环；\r\n```\r\n\r\n### 16、final 关键字\r\n\r\n### 17、this 关键字\r\n\r\n### 18、transient 关键字\r\n\r\n### 19、instanceof 关键字\r\n\r\n### 20、字符型常量和字符串常量的区别 \r\n\r\n### 21、成员变量与局部变量的区别有那些\r\n\r\n### 22、自动拆箱装箱\r\n\r\n### 23、接口&抽象类\r\n\r\n### 24、Java 引用\r\n\r\n### 25、hashCode&equals\r\n\r\n### 26、Comparable和Comparator\r\n\r\n\r\n\r\n## 二、面向对象部分\r\n\r\n## 三、WEB相关部分\r\n\r\n❤️❤️❤️未完待续❤️❤️❤️\r\n\r\n\r\n",
      "data": {
        "title": "Java基础知识",
        "date": "2019-11-07 16:05:09",
        "tags": [
          "Java"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/java-ji-chu-zhi-shi.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "万丈高楼平地起，掌握并牢记基础知识，是学习后面知识的根基，下面我们一起回顾一下Java的基础知识吧！\r",
      "fileName": "java-ji-chu-zhi-shi"
    },
    {
      "content": "## ❤️ 欢迎语\n> 欢迎来到我的小站呀，很高兴遇见你！🤝\n\n## 🏠 关于本站\n> 这是我的博客，主要是记录一些IT技术方面的知识，以及一些生活体会。\n\n## 📞 联系我呀\n> 我的邮箱：bofengsun@163.com\n> 微信公众号：搜索“玩命有人疼”",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    }
  ],
  "tags": [
    {
      "name": "单点登陆",
      "slug": "_YPT5EBNp",
      "used": true
    },
    {
      "name": "Jmeter",
      "slug": "-XHsEfy82",
      "used": true
    },
    {
      "name": "Shiro",
      "slug": "3pUmHBzD3",
      "used": true
    },
    {
      "name": "Java",
      "slug": "qpWMRguFz",
      "used": true
    },
    {
      "name": "Authentication",
      "slug": "kY59_WAGg",
      "used": false
    },
    {
      "name": "Gridea",
      "slug": "y28fz_ap3",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}