<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bofengsun.github.io/</id>
    <title>玩命有人疼</title>
    <updated>2019-12-27T09:03:17.407Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bofengsun.github.io/"/>
    <link rel="self" href="https://bofengsun.github.io//atom.xml"/>
    <subtitle>重新开始，从心开始！</subtitle>
    <logo>https://bofengsun.github.io//images/avatar.png</logo>
    <icon>https://bofengsun.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 玩命有人疼</rights>
    <entry>
        <title type="html"><![CDATA[注解基本知识]]></title>
        <id>https://bofengsun.github.io//post/zhu-jie-ji-ben-zhi-shi</id>
        <link href="https://bofengsun.github.io//post/zhu-jie-ji-ben-zhi-shi">
        </link>
        <updated>2019-12-11T08:55:46.000Z</updated>
        <summary type="html"><![CDATA[<p>注解：在SpringBoot中存在大量的注解，我们需要对注解有一个基本的认识以及应用，主要包括这几个方面：注解的分类、注解的语法、注解的使用、注解解析</p>
]]></summary>
        <content type="html"><![CDATA[<p>注解：在SpringBoot中存在大量的注解，我们需要对注解有一个基本的认识以及应用，主要包括这几个方面：注解的分类、注解的语法、注解的使用、注解解析</p>
<!-- more -->
<h1 id="注解">注解</h1>
<p>我对注解的理解是，注解就是一种标记，通过这个标记我们可以获取一定的关联信息。</p>
<h1 id="为什么要学习注解">为什么要学习注解</h1>
<p>在这里主要是现有的框架中存在大量的注解，我们需要知道主键的基本概念以及使用方法，能够更加理解这些框架，另一方面，学习注解，我们可以开发自定义注解使得代码更加简洁清晰。</p>
<h1 id="注解的分类">注解的分类</h1>
<h3 id="1-按照声明周期">1、按照声明周期</h3>
<p>源码注解（仅在.java文件中存在，经过编译就不存在了）<br>
编译时注解（在编译时起作用，即在.class文件中也仍然存在）<br>
运行时注解（在运行阶段起作用，有时会影响程序的运行逻辑）</p>
<h3 id="2-按照来源">2、按照来源</h3>
<p>JDK自带的注解<br>
第三方框架注解<br>
自定义注解</p>
<h3 id="3-元注解对注解进行注解的注解">3、元注解（对注解进行注解的注解）</h3>
<h2 id="注解的语法">注解的语法</h2>
<p>我们首先看一下@SpringBootApplication注解，这是SpringBoot HelloWorld程序中的主类的主键，我们看一下他的源码</p>
<pre><code>package org.springframework.boot.autoconfigure;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.context.TypeExcludeFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;
import org.springframework.core.annotation.AliasFor;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
    //...
}
</code></pre>
<p>我们通过该主键就可以帮我们自动配置好SpringBoot应用程序，通过包名我们可以看到@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan这三个注解也是属于Spring自己的注解，所以@SpringBootApplication注解是一个组合注解，去除这些组合信息，以及不必要的代码，我们再来看一下该注解：</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface SpringBootApplication {
    //...
}
</code></pre>
<p>这就是一个注解的基本框架，首先我们知道，定义一个主键的关键字是@interface，另外我们还看到有@Target、@Retention、@Documented、@Inherited四个注解就是标注在注解上的注解即元注解，下面我们对这四个注解进行详细的讲解：<br>
<strong>@Target</strong>：注解的作用目标，即<strong>作用域</strong>。<br>
可以看到它的取值是一个枚举类型，我们看一下该枚举源码：</p>
<pre><code>public enum ElementType {
    /**Class, interface (including annotation type), or enum declaration*/
    /** 类，接口   重要*/
    TYPE,
    
    /** Field declaration (includes enum constants) */
    /** 字段声明  重要*/
    FIELD,

    /** Method declaration */
     /** 方法声明  重要*/
    METHOD,

    /** Formal parameter declaration */
    /** 参数声明  重要*/
    PARAMETER,

    /** Constructor declaration */
    /** 构造函数声明  重要*/
    CONSTRUCTOR,

    /** Local variable declaration */
    /** 构局部变量声明*/
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    /** 注解类型声明*/
    ANNOTATION_TYPE,

    /** Package declaration*/
    /** 包声明*/
    PACKAGE,

    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}
</code></pre>
<p>注解的作用域可以来自这些值</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    ElementType[] value();
}
</code></pre>
<p>通过查看@Target的源码可以知道，其取值是一个ElementType[]数组所以，其值也可以是ElementType中的组合例如</p>
<pre><code>@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {
  //...
}
</code></pre>
<p>Spring中的@Bean注解的作用域就是可以是在方法声明中或者注解类型声明中。<br>
<strong>@Retention</strong>：表示注解的声明周期，即可以是源码阶段、编译时、运行时，我们可以看一下RetentionPolicy枚举的源码</p>
<pre><code>public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler. 
     * 源码阶段
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     * 编译时阶段
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     * 运行时阶段
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
</code></pre>
<p><strong>@Documented</strong>：标识在生成javadoc文档时包含该注解信息<br>
<strong>@Inherited</strong>:标识允许子类继承<br>
<strong>注解的成员</strong>：注解的成员以无参无异常的方法进行声明，可以指定默认值，成员的类型包括基本数据类型以及String、Class、Annotation、Enumeration<br>
##注解的使用<br>
@&lt;注解名&gt;（&lt;成员1&gt;=&lt;成员1值&gt;，&lt;成员2&gt;=&lt;成员2值&gt;，...）<br>
##注解解析<br>
注解解析主要是利用反射进行解析的下面我们看一个简单的例子</p>
<pre><code>package com.example.demo.annotation;

import java.lang.annotation.*;
/**
 * 描述：@Description用来对类或者方法进行注释说明的注解
 */
@Target({ElementType.TYPE,ElementType.METHOD})//作用域：类、方法
@Retention(RetentionPolicy.RUNTIME)//生命周期  运行时
@Inherited//允许继承
@Documented//生成javadoc描述符
public @interface Description {
    String value();
}
</code></pre>
<pre><code>package com.example.demo.annotation;

/**
 * 描述：普通类，用来使用@Description注解
 */
@Description(&quot;用户类&quot;)
public class User {

    private String username;

    private String password;

    @Description(&quot;用户名&quot;)
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
    @Description(&quot;密码&quot;)
    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
</code></pre>
<pre><code>package com.example.demo.annotation;

import java.lang.reflect.Method;

/**
 * 描述：解析注解
 */
public class ParseAnnotation {

    public static void main(String[] args) throws ClassNotFoundException {
        //利用反射获取类信息
        Class c=Class.forName(&quot;com.example.demo.annotation.User&quot;);
        //判断是否为@Description注解标注的类
        boolean isDescriptionAnnotationClass=c.isAnnotationPresent(Description.class);
        if(isDescriptionAnnotationClass){
            //如果是获取注解信息
            Description description= (Description) c.getAnnotation(Description.class);
            //输出
            System.out.println(description.value());
        }
        //利用反射获取所有方法信息
        Method [] ms=c.getMethods();
        for (Method m:ms){
            //判断是否为@Description注解标注的方法
            boolean isDescriptionAnnotationMethod=m.isAnnotationPresent(Description.class);
            if(isDescriptionAnnotationMethod){
                //如果是获取注解信息
                Description description= (Description) m.getAnnotation(Description.class);
                //输出
                System.out.println(description.value());
            }
        }
    }
}
</code></pre>
<p>运行结果：<br>
<img src="https://upload-images.jianshu.io/upload_images/8069900-bac4addc5cc531d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注解.png"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 常用注解]]></title>
        <id>https://bofengsun.github.io//post/spring-boot-chang-yong-zhu-jie</id>
        <link href="https://bofengsun.github.io//post/spring-boot-chang-yong-zhu-jie">
        </link>
        <updated>2019-12-08T08:46:26.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring Boot中常用注解：@Configuration、@ComponentScan、@Bean、@Component、@Configuration、@Controller、@Service、@Repository、@RequestMapping、@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@ResponseBody、@RestController、@PathVariable、@RequestParam</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring Boot中常用注解：@Configuration、@ComponentScan、@Bean、@Component、@Configuration、@Controller、@Service、@Repository、@RequestMapping、@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@ResponseBody、@RestController、@PathVariable、@RequestParam</p>
<!-- more -->
<h1 id="configuration注解">@Configuration注解</h1>
<p>@Configuration注解意思是往容器中加入一个组件，该组件的主要作用是进行一些配置，相当于之前配置的配置文件，下面我们用两种方式对其进行演示：<br>
<strong>准备工作</strong><br>
pom.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.itbofeng&lt;/groupId&gt;
    &lt;artifactId&gt;SpringDemo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p><strong>配置文件方式</strong><br>
1、创建类路径配置文件beans.xml<br>
2、创建User类</p>
<pre><code>package com.itbofeng.bean;
/**
 * 描述：User Bean 用来测试
 */
public class User {
    private String name;
    private Integer age;
    public User() {
    }
    public User(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<p>2、在配置文件中加入User bean</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.itbofeng.bean.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;13&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3、运行测试</p>
<pre><code>import com.itbofeng.bean.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * 描述：测试类
 */
public class MainConfigTest {
    @Test
    public void testXml(){
        //通过配置文件创建容器，需要传入配置文件
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        //获取bean
        User user= (User) applicationContext.getBean(&quot;user&quot;);
        System.out.println(user);
    }
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/8069900-63f532462b51fd2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"><br>
<strong>注解方式</strong><br>
1、创建配置类MainConfig.java<br>
2、注册组件用@Bean注解<br>
我们看一下代码</p>
<pre><code>package com.itbofeng;

import com.itbofeng.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 描述：该类对@Configuration注解进行讲解
 */
@Configuration
public class MainConfig {
    /**
     * 给容器中加入Bean，相当于配置文件总的bena标签
     * id 默认是方法名称，也可以指定id
     * class 即返回值类型
     */
    @Bean
    public User user(){
        return new User(&quot;lisi&quot;,18);
    }
}
</code></pre>
<p>以上配置类就等同于beans.xml中的内容<br>
3、运行测试</p>
<pre><code>    @Test
    public void testAnnoation(){
        //通过注解创建容器，需要传入配置类
        ApplicationContext applicationContext=new AnnotationConfigApplicationContext(MainConfig.class);
        //获取bean
        User user= (User) applicationContext.getBean(&quot;user&quot;);
        System.out.println(user);
    }
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/8069900-2cc400ec1dd6c52e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"><br>
有了该例子相信大家对@Configuration有了一个基本的认识，其就相当于Spring配置文件的功能，不过是以注解的方式进行体现，之前我们在配置文件中多采用包扫描的方式进行，那么这种方式在配置类中如何体现呢，下面我们引入第二个注解@ComponentScan包扫描注解<br>
####@ComponentScan注解<br>
@ComponentScan注解就相当于 xml配置文件中的context:component-scan标签，下面讲解一下他的基本使用方法：<br>
xml</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.itbofeng&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<p>java</p>
<pre><code>@Configuration
@ComponentScan(&quot;com.itbofeng&quot;)
public class MainConfig {
  //...
}
</code></pre>
<p>这样就可以对com.itbofeng包下的@Controller、@Service、@Component、@Respoitory、@Component标注的类进行扫描，并由Spring容器进行管理，当然spring并不是这么简单的，它还可以进行排除，仅包含，我们看一下xml和java的语法<br>
xml</p>
<pre><code>    &lt;!--包扫描、如果想要include-filter起作用需要设置use-default-filters=&quot;false&quot;,禁用默认过滤规则--&gt;
    &lt;context:component-scan base-package=&quot;com.itbofeng&quot; use-default-filters=&quot;false&quot;&gt;
        &lt;!--排除--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;&gt;&lt;/context:exclude-filter&gt;
        &lt;!--仅包括--&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;&gt;&lt;/context:include-filter&gt;
    &lt;/context:component-scan&gt;
</code></pre>
<p>java</p>
<pre><code>@Configuration
@ComponentScan(value = &quot;com.itbofeng&quot;,excludeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})
},
includeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Service.class})
},useDefaultFilters = false)
public class MainConfig {
  //...
}
</code></pre>
<p>对于jdk1.8及以上@ComponentScan支持重复注解，另外还有@ComponentScans注解可以写多个@ComponentScan注解，另外需要说明的两种过滤方式排除和仅包含在一个包扫描中仅可出现一个。<br>
关于@ComponentScan.Filter.type的取值大家可以参考：https://www.cnblogs.com/kevin-yuan/p/5068448.html<br>
我们之前看到过@Bean注解，但并未对该注解进行详细介绍<br>
<strong>@Bean</strong><br>
前面我们初步体验了一下@bean注解的作用也很简单常用来标注在方法上面，来表示往spring容器中添加一个组件如上面的利用@Bean往容器中添加一个User组件，在xml中我们不仅能够往容器中添加一个bean而且还能设置lazy-init、scope的属性，这些属性在注解里面可以这样使用</p>
<pre><code>    @Lazy
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Bean
    public User user(){
        return new User(&quot;lisi&quot;,18);
    }
</code></pre>
<p>等同于</p>
<pre><code>&lt;bean id=&quot;user&quot; class=&quot;com.itbofeng.bean.User&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;13&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>@Component、@Configuration、@Controller、@Service、@Repository</strong><br>
其实在web开发中我们最常用的组件是@Component、@Configuration、@Controller、@Service、@Repository这几个注解都有一个作用，往容器中添加一个组件他们都是@Component组合注解，他们标注在类上面，表示往spring容器中添加一个组件，@Controller用来标注在Controller上面，@Service用来标注Service层上面，@Repository用来标注在持久层上面，@Configuration用来标注在配置类上，@Component用来标注在其他组件上面。<br>
<strong>@RequestMapping、@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</strong><br>
在SpringMVC中还有个重要的注解@RequestMapping，它是用来做地址映射的，就是说，我们一个请求，该如何映射到我们的方法上面。它可用于类或方法上，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。RequestMapping注解有六个属性，其中常用的有<strong>value， method</strong>、非常用的有params，headers、consumes，produces，**value：指定请求的实际地址，method：  指定请求的method类型， GET、POST、PUT、DELETE等（符合Rest风格）；params： 指定request中必须包含某些参数值是，才让该方法处理。headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。**consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回，例子：</p>
<pre><code>package com.itbofeng.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
@Controller
public class UserController {
    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)
    public String hello(){
        return &quot;hello&quot;;
    }
}
</code></pre>
<p><strong>@ResponseBody</strong><br>
如果我们配置了视图解析器ViewResolver，如果我们访问 localhost:8080/hello还并不能够返回hello，其会返回视图解析器的前缀+hello+后缀的页面，如果我们想要其向浏览器返回hello内容，则需要@ResponseBody注解，该注解就是将返回值直接返回给浏览器，如果返回值是一个对象，则会返回该对象的json对象，其可以标注在方法上表示该方法返回遵守该规则，也可以标注在类上，表示该类下的所有方法都遵守该规则。用法如下：</p>
<pre><code>    @ResponseBody
    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)
    public String hello(){
        return &quot;hello&quot;;
    }
</code></pre>
<p><strong>@RestController</strong><br>
@RestController=@Controller+@ResponseBody<br>
<strong>@PathVariable、@RequestParam</strong><br>
@PathVariable 路径变量，主要是将路径中的值映射为变量（Rest编程风格推荐），<br>
@RequestParam 请求参数，主要是获取请求中的参数<br>
下面我们举例说明：<br>
地址① http://localhost:8080/hello?name=lisi<br>
地址② http://localhost:8080/hello/lisi<br>
我们通过两种方式来获取变量请求中的lisi，<br>
@RequestParam 方式</p>
<pre><code>    @ResponseBody
    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)
    public String hello(@RequestParam(&quot;name&quot;) String name){
        return &quot;hello &quot;+name;
    }
</code></pre>
<p>@PathVariable 方式</p>
<pre><code>    @ResponseBody
    @RequestMapping(value = &quot;/hello/{name}&quot;,method = RequestMethod.GET)
    public String hello(@PathVariable(&quot;name&quot;) String name){
        return &quot;hello &quot;+name;
    }
</code></pre>
<p><strong>注意：请求路径的变化</strong><br>
今天注解部分就先将到这里，后面我们在学习过程中学到什么，再具体讲解其用法，关于这些注解的在什么时候起作用的呢，需要我们学习了Spring的运行流程之后，才能进一步的进行深入了解，下一节，我们学习一下往容器中添加Bean的几种方式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[与你相遇恰似那一场梦]]></title>
        <id>https://bofengsun.github.io//post/yu-ni-xiang-yu-qia-si-na-yi-chang-meng</id>
        <link href="https://bofengsun.github.io//post/yu-ni-xiang-yu-qia-si-na-yi-chang-meng">
        </link>
        <updated>2019-12-04T06:30:19.000Z</updated>
        <summary type="html"><![CDATA[<p>我走在乡间的小路<br>
想起了往事篇篇<br>
你看</p>
]]></summary>
        <content type="html"><![CDATA[<p>我走在乡间的小路<br>
想起了往事篇篇<br>
你看</p>
<!-- more -->
<p>夏天，花丛，小道<br>
萍水相逢，你的笑容，便永驻我心间</p>
<p>我们一路走来<br>
爱使你我相遇相知相思相守<br>
你我在一起的两千多个日子</p>
<p>夏冬与春秋，地北与天南<br>
萍踪靡定，我的心，永在你身边</p>
<p>那夜，梦到你出嫁<br>
一掀起盖头，我傻傻地看你，你娇羞地看我<br>
场面热闹，街坊邻里，拍手叫好<br>
梦醒，千里相思，想对你说，嫁我好吗？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[相思相守]]></title>
        <id>https://bofengsun.github.io//post/xiang-si-xiang-shou</id>
        <link href="https://bofengsun.github.io//post/xiang-si-xiang-shou">
        </link>
        <updated>2019-12-01T05:51:45.000Z</updated>
        <summary type="html"><![CDATA[<p>长相思，长相思。若问相思甚了期，除非相见时。<br>
怕相思，已相思，轮到相思无处辞，眉间露一丝。</p>
<p>长相守，长相守，执子相守寄无期，但凭风雨处。<br>
念相守，寄相守，偕子相守深情处，怀中俯首时。</p>
]]></summary>
        <content type="html"><![CDATA[<p>长相思，长相思。若问相思甚了期，除非相见时。<br>
怕相思，已相思，轮到相思无处辞，眉间露一丝。</p>
<p>长相守，长相守，执子相守寄无期，但凭风雨处。<br>
念相守，寄相守，偕子相守深情处，怀中俯首时。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单点登陆（SSO）介绍]]></title>
        <id>https://bofengsun.github.io//post/dan-dian-deng-lu-ssojie-shao</id>
        <link href="https://bofengsun.github.io//post/dan-dian-deng-lu-ssojie-shao">
        </link>
        <updated>2019-11-26T05:23:34.000Z</updated>
        <summary type="html"><![CDATA[<p>单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。</p>
]]></summary>
        <content type="html"><![CDATA[<p>单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。</p>
<!-- more -->
<h2 id="1-产生背景">1、产生背景</h2>
<p>单点登陆的产生主要是随着企业业务的发展，企业会有许多系统来处理不通的业务，而如果各个系统均单独做登陆认证功能，会造成多个系统都需要开发一样的认证逻辑的功能，而且用户在使用时也需要频繁的进行登陆退回，而单点登陆，就是多个系统共同信任同一份票据，这份票据，可以在各个业务系统中进行使用，以此来实现身份认证的组合。</p>
<h2 id="2-实现流程">2、实现流程</h2>
<p>1、用户1登陆业务系统1<br>
2、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径1）<br>
3、用户没有登陆，跳转到登陆页面并携带（路径1）<br>
4、用户登陆，并保存凭据，重定向到（路径1），并携带凭据<br>
5、业务系统1 存储凭据<br>
6、用户2登陆业务系统2<br>
7、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径2）<br>
8、用户已登陆，重定向到（路径2），并携带凭据<br>
9、业务系统2，存储凭据</p>
<h2 id="3-客户端与服务器端的功能">3、客户端与服务器端的功能</h2>
<p>客户端：<br>
1、拦截子系统未登录用户请求，跳转至sso认证中心<br>
2、接收并存储sso认证中心发送的令牌<br>
3、与服务器端通信，校验令牌的有效性<br>
4、建立局部会话<br>
5、拦截用户注销请求，向sso认证中心发送注销请求<br>
服务器端：<br>
1、验证用户的登录信息<br>
2、创建全局会话<br>
3、创建授权令牌<br>
4、与客户端通信发送令牌<br>
6、校验客户端令牌有效性<br>
7、接收客户端注销请求，注销会话</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 密码加密与会话管理介绍]]></title>
        <id>https://bofengsun.github.io//post/shiro-mi-ma-jia-mi</id>
        <link href="https://bofengsun.github.io//post/shiro-mi-ma-jia-mi">
        </link>
        <updated>2019-11-24T15:54:05.000Z</updated>
        <summary type="html"><![CDATA[<p>密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。</p>
<!-- more -->
<h1 id="shiro-密码加密">Shiro 密码加密</h1>
<h2 id="0-前置代码后面用到以便理解">0、前置代码:后面用到，以便理解</h2>
<pre><code class="language-Java">    /**
     * 加密次数
     */
    Integer HASH_ITERATIONS=1024;
    /**
     * 加密算法
     */
    String HASH_ALGORITHMNAME=&quot;MD5&quot;;
</code></pre>
<h2 id="1-注册注册和认证时密码需要用同样的策略以保证密码密文的一致性">1、注册：注册和认证时密码需要用同样的策略，以保证密码密文的一致性。</h2>
<pre><code class="language-Java">    /**
     * 注册
     * @param registerVo
     * @return
     */
    @PostMapping(&quot;/register&quot;)
    public ResultVo&lt;Boolean&gt; register(@RequestBody LoginRegisterVo registerVo){
        //加密方式 可另行制定
        String algorithmName= Constant.HASH_ALGORITHMNAME;
        //密码明文
        Object source=registerVo.getPassword();
        //密码盐值 可另行制定
        Object salt=registerVo.getUsername();
        //加密次数 可另行制定
        int hashIterations=Constant.HASH_ITERATIONS;
        SimpleHash simpleHash = new SimpleHash(algorithmName, source, salt, hashIterations);
        //加密后密码
        String password = simpleHash.toHex();
        log.info(password);
        boolean flag=userService.addUser(registerVo.getUsername(),password);
        if(!flag){
            ResultVo.failure(Result.REGISTER_FAILURE);
        }
        return ResultVo.success(true);
    }
</code></pre>
<p>根据以上注册可生成密码，那么在登陆的时候，该如何进行匹配呢？下面我来看一下登录如何进行</p>
<h2 id="2-认证在进行用户认证dogetauthenticationinfo时需要指定盐值颜值需要唯一">2、认证：在进行用户认证(doGetAuthenticationInfo)时需要指定盐值，颜值需要唯一</h2>
<pre><code class="language-Java">    /**
     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法
     * @param authenticationToken 令牌
     * @return 认证的信息
     * @throws AuthenticationException 认证异常
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        log.info(&quot;开始进行身份认证！&quot;);
        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;
        String username = usernamePasswordToken.getUsername();
        User user = userService.getByUsername(username);
        if(user==null){
            log.info(&quot;用户未找到！&quot;);
            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());
        }else if (Constant.USER_LOCKED.equals(user.getStatus())){
            log.info(&quot;用户被锁定！&quot;);
            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());
        }else {
            Object principal=user.getId();
            String credentials=user.getPassword();
            String realmName=getName();
            //指定盐值
            ByteSource credentialsSalt = ByteSource.Util.bytes(usernamePasswordToken.getUsername());
            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,credentialsSalt,realmName);
            log.info(&quot;用户认证！&quot;);
            return simpleAuthenticationInfo;
        }
    }
</code></pre>
<h2 id="3-配置realm在realm密码策略以及加密次数">3、配置Realm:在Realm密码策略以及加密次数</h2>
<pre><code class="language-Java">    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(Constant.HASH_ALGORITHMNAME);
        credentialsMatcher.setHashIterations(Constant.HASH_ITERATIONS);
        customRealm.setCredentialsMatcher(credentialsMatcher);
        return customRealm;
    }
</code></pre>
<h2 id="4-扩展">4、扩展</h2>
<p>实际上Shiro支持多种密码策略，具体可以查看org.apache.shiro.authc.credential.CredentialsMatcher的子类</p>
<h1 id="shiro-会话管理">Shiro 会话管理</h1>
<h2 id="1-使用当前会话">1、使用当前会话</h2>
<pre><code class="language-Java">    SecurityUtils.getSubject().getSession();
</code></pre>
<h2 id="2-会话管理器sessionmanager管理session包括创建-维护-删除-失效-验证等工作">2、会话管理器(SessionManager):管理session包括创建、维护、删除、失效、验证等工作。</h2>
<pre><code class="language-Java">/**
 * 自定义SessionManager:从请求头中也可获取JSESSIONID
 */
@Slf4j
public class CustomWebSessionManager extends DefaultWebSessionManager{

    private static final String JSESSIONID=&quot;JSESSIONID&quot;;

    @Override
    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {
        Serializable id = super.getSessionId(request,response);
        //如果从Cookie中没有获取到SessionId,则从请求头中获取
        if (id == null) {
            id=WebUtils.toHttp(request).getHeader(JSESSIONID);
        }
        return id;
    }
}
</code></pre>
<h2 id="3-会话监听器sessionlistener监听会话状态触发对应的方法">3、会话监听器(SessionListener):监听会话状态，触发对应的方法</h2>
<pre><code class="language-Java">/**
 * 自定义SerssionListener 维护Session中的值
 */
public class CustomSessionListener implements SessionListener {
    @Override
    public void onStart(Session session) {
        RedisUtil.set(session.getId().toString(),session);
    }

    @Override
    public void onStop(Session session) {
        RedisUtil.del(session.getId().toString());
    }

    @Override
    public void onExpiration(Session session) {
        RedisUtil.del(session.getId().toString());
    }
}
</code></pre>
<h2 id="4-会话增删改查接口sessiondao">4、会话增删改查接口(SessionDAO)</h2>
<pre><code class="language-Java">public interface SessionDAO {
    Serializable create(Session var1);

    Session readSession(Serializable var1) throws UnknownSessionException;

    void update(Session var1) throws UnknownSessionException;

    void delete(Session var1);

    Collection&lt;Session&gt; getActiveSessions();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 权限认证]]></title>
        <id>https://bofengsun.github.io//post/shiro-quan-xian-ren-zheng</id>
        <link href="https://bofengsun.github.io//post/shiro-quan-xian-ren-zheng">
        </link>
        <updated>2019-11-20T04:39:28.000Z</updated>
        <summary type="html"><![CDATA[<p>前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。</p>
<!-- more -->
<h2 id="1-实现权限认证逻辑">1、实现权限认证逻辑</h2>
<p>基于前面的文章，自定义Realm继承AuthorizingRealm 需要实现doGetAuthenticationInfo 和 doGetAuthorizationInfo,其中doGetAuthenticationInfo主要用来身份认证，doGetAuthorizationInfo主要用来进行权限认证，具体代码如下：<br>
前置代码：</p>
<pre><code class="language-Java">    private static final Map&lt;String,Set&lt;String&gt;&gt; USER_ROLE= new HashMap&lt;&gt;();
    static {
        USER_ROLE.put(&quot;1&quot;,new HashSet&lt;&gt;(Arrays.asList(&quot;item:add&quot;,&quot;item:search&quot;,&quot;item:update&quot;,&quot;item:delete&quot;)));
        USER_ROLE.put(&quot;2&quot;,new HashSet&lt;&gt;(Arrays.asList(&quot;item:add&quot;,&quot;item:search&quot;)));
    }

    @Override
    public Set&lt;String&gt; getUserRoles(String userId) {
        Set&lt;String&gt; result = USER_ROLE.get(userId);
        return result!=null?result:Collections.EMPTY_SET;
    }
</code></pre>
<pre><code class="language-Java">    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        log.info(&quot;开始进行权限认证！&quot;);
        SimpleAuthorizationInfo simpleAuthorizationInfo=new SimpleAuthorizationInfo();
        String userId = (String)principalCollection.getPrimaryPrincipal();
        Set&lt;String&gt; userRoles = roleService.getUserRoles(userId);
        for (String userRole:userRoles){
            simpleAuthorizationInfo.addStringPermission(userRole);
        }
        return simpleAuthorizationInfo;
    }
</code></pre>
<h2 id="2-配置lifecyclebeanpostprocessor-defaultadvisorautoproxycreator-authorizationattributesourceadvisor">2、配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor</h2>
<p>因为Shiro需要对Controller进行代理，所以需要开启Controller的代理，需要配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor</p>
<pre><code class="language-Java">    @Bean
    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor(){
        return new LifecycleBeanPostProcessor();
    }
    @Bean
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator(){
        DefaultAdvisorAutoProxyCreator creator=new DefaultAdvisorAutoProxyCreator();
        creator.setProxyTargetClass(true);
        return creator;
    }
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor=new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }
</code></pre>
<h2 id="3-配置请求权限码">3、配置请求权限码</h2>
<p>通过注解配置权限信息，@RequiresRoles、@RequiresPermissions 以@RequiresPermissions为例：</p>
<pre><code class="language-Java">    @RequiresPermissions(&quot;item:search&quot;)
    @GetMapping(&quot;/search&quot;)
    public ResultVo&lt;String&gt; search(){
        return ResultVo.success(&quot;search&quot;);
    }
    @RequiresPermissions(&quot;item:add&quot;)
    @GetMapping(&quot;/add&quot;)
    public ResultVo&lt;String&gt; add(){
        return ResultVo.success(&quot;add&quot;);
    }
    @RequiresPermissions(&quot;item:update&quot;)
    @GetMapping(&quot;/update&quot;)
    public ResultVo&lt;String&gt; update(){
        return ResultVo.success(&quot;update&quot;);
    }
    @RequiresPermissions(&quot;item:delete&quot;)
    @GetMapping(&quot;/delete&quot;)
    public ResultVo&lt;String&gt; delete(){
        return ResultVo.success(&quot;delete&quot;);
    }
</code></pre>
<h2 id="4-演示效果">4、演示效果</h2>
<p>用户登陆：<br>
<img src="https://bofengsun.github.io//post-images/1573745823357.png" alt="登陆用户"><br>
有权限：<br>
<img src="https://bofengsun.github.io//post-images/1573745976892.png" alt="有权限"><br>
无权限：<br>
<img src="https://bofengsun.github.io//post-images/1573746081151.png" alt="无权限"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jmeter 体验之旅]]></title>
        <id>https://bofengsun.github.io//post/jmeter-ti-yan-zhi-lu</id>
        <link href="https://bofengsun.github.io//post/jmeter-ti-yan-zhi-lu">
        </link>
        <updated>2019-11-17T11:23:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。</p>
<!-- more -->
<h2 id="jmeter-介绍">Jmeter 介绍</h2>
<p>Apache JMeter 是一款开源的Java开发的用于进行软件性能测试的软件。</p>
<h2 id="安装和运行">安装和运行</h2>
<p>下载地址：http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-5.2.zip<br>
运行：windows环境： “bin/jmeter.bat”   linux环境： “bin/jmeter.sh”<br>
切换语言： 启动Jmeter 后， 点击 Options -&gt; Choose Language -&gt; Chinese[Simplified]  来选择简体中文<br>
截图如下：<br>
<img src="https://bofengsun.github.io//post-images/1573559262706.png" alt="Jmeter"></p>
<h2 id="案例">案例</h2>
<h3 id="添加默认设置">添加默认设置</h3>
<p>1、添加 HTTP Cookie管理器<br>
<img src="https://bofengsun.github.io//post-images/1573563560952.png" alt="HTTP Cookie管理器"><br>
2、添加 默认请求头<br>
<img src="https://bofengsun.github.io//post-images/1573563633762.png" alt="默认请求头"><br>
3、添加 默认请求<br>
<img src="https://bofengsun.github.io//post-images/1573563677239.png" alt="默认请求"></p>
<h3 id="添加线程组">添加线程组</h3>
<p>参数说明：<br>
线程数：表示需要启动的线程数量<br>
Ramp-Up时间：多少秒内启动这些线程，也就是说会在这个时间内启动这么多线程，如果设置为0，则表示同时启动<br>
循环次数：表示重复运行多少次，永远表示一直重复直到时间结束<br>
调度器配置：在配置调度器时生效，持续时间：就是执行多久<br>
<img src="https://bofengsun.github.io//post-images/1573563731549.png" alt="添加线程组"></p>
<h3 id="添加定时器">添加定时器</h3>
<figure data-type="image" tabindex="1"><img src="https://bofengsun.github.io//post-images/1573609185253.png" alt="添加定时器"></figure>
<h3 id="添加事务控制器">添加事务控制器</h3>
<figure data-type="image" tabindex="2"><img src="https://bofengsun.github.io//post-images/1573563817861.png" alt="事务控制器"></figure>
<h3 id="添加请求">添加请求</h3>
<figure data-type="image" tabindex="3"><img src="https://bofengsun.github.io//post-images/1573609251077.png" alt="添加请求"></figure>
<h3 id="添加断言">添加断言</h3>
<figure data-type="image" tabindex="4"><img src="https://bofengsun.github.io//post-images/1573609303540.png" alt="添加断言"></figure>
<h3 id="添加查看结果树">添加查看结果树</h3>
<figure data-type="image" tabindex="5"><img src="https://bofengsun.github.io//post-images/1573609390929.png" alt="添加查看结果树"></figure>
<h3 id="添加聚合报告">添加聚合报告</h3>
<figure data-type="image" tabindex="6"><img src="https://bofengsun.github.io//post-images/1573609486454.png" alt="添加聚合报告"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 身份认证（续）]]></title>
        <id>https://bofengsun.github.io//post/shiro-authentication-2</id>
        <link href="https://bofengsun.github.io//post/shiro-authentication-2">
        </link>
        <updated>2019-11-13T05:25:45.000Z</updated>
        <summary type="html"><![CDATA[<p>上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。</p>
<!-- more -->
<h2 id="一-如何和支持web-app-以及其他方式进行身份认证">一、如何和支持WEB、APP、以及其他方式进行身份认证？</h2>
<p>先回顾一下上一节我们的登陆部分代码：</p>
<pre><code class="language-Java">/**
 * 认证控制器
 */
@RestController
@RequestMapping(&quot;/auth&quot;)
@Slf4j
public class AuthController {

    /**
     * 登陆
     * @param username 用户名
     * @param password 密码
     * @return 登陆结果
     */
    @PostMapping(&quot;/login&quot;)
    public ResultVo&lt;String&gt; login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password){
        Subject currentUser = SecurityUtils.getSubject();
        if (!currentUser.isAuthenticated()) {
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            try {
                currentUser.login(token);
                return ResultVo.success(currentUser.getSession().getId().toString());
            }catch (LockedAccountException lae) {
                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);
            }
            catch (AuthenticationException ae) {
                return ResultVo.failure(Result.LOGIN_FAILURE);
            }
        }else {
            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);
        }
    }
}
</code></pre>
<p>可以看到我们在登陆成功后，把用户的SessionId返回给客户端，但在传统WEB其实是不需要的，因为在认证成功后会将SessionId保存在cookie里JSESSIONID，那么如果我们需要兼容APP或者其他方式这样就行不通，一种比较简单的方式就是我们把SessionId返回给客户端，客户端保存一份，每次请求时，将其作为请求头请求服务端，同时服务端也要改变获取SessionId的方式，不是从cookie里获取，而是从header里获取，这样就可以解决该问题，那么下面我们就看一下在Shiro中该如何做吧。<br>
1、自定义SessionManager继承DefaultWebSessionManager</p>
<pre><code class="language-Java">/**
 * 自定义SessionManager
 */
@Slf4j
public class CustomWebSessionManager extends DefaultWebSessionManager{

    private static final String JSESSIONID=&quot;JSESSIONID&quot;;

    @Override
    public Serializable getSessionId(SessionKey key) {
        Serializable id = super.getSessionId(key);
        //如果从Cookie中没有获取到SessionId,则从请求头中获取
        if (id == null) {
            HttpServletRequest request = (HttpServletRequest)WebUtils.getRequest(key);
            id = request.getHeader(JSESSIONID);
        }
        return id;
    }
}
</code></pre>
<p>2、将自定义的SessionManager放入容器中<br>
3、设置SecurityManager的SessionManager为自定义的SessionManager</p>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/openapi/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setSessionManager(sessionManager);
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义SessionManager
     * @return
     */
    @Bean(&quot;sessionManager&quot;)
    public CustomWebSessionManager customWebSessionManager(){
        return new CustomWebSessionManager();
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }
}
</code></pre>
<p>4、客户端登陆成功后将sessionId保存起来，每次请求的时候带上该请求头</p>
<h2 id="二-分布式环境下如何来维护session的呢">二、分布式环境下，如何来维护Session的呢？</h2>
<p>那么这里就是如何统一维护Session的问题了，我们一般会将Session保存在缓存中间件里，例如Redis，这样即保证性能，又实现功能，下面我们就体验一下吧？<br>
1、连接Redis以及编写RedisUtil（该部分仍是采用MAP进行处理，待后面和Redis继承时修改这里）</p>
<pre><code class="language-Java">/**
 * Redis工具类
 */
public class RedisUtil {
    static Map&lt;String,Object&gt; SESSION_ID_CACHE=new HashMap&lt;&gt;();
    public static void set(String key,Object value){
        SESSION_ID_CACHE.put(key,value);
    }
    public static Object get(String key){
        return SESSION_ID_CACHE.get(key);
    }
    public static void del(String key){
        SESSION_ID_CACHE.remove(key);
    }
    public static Collection values(){
        return SESSION_ID_CACHE.values();
    }
}
</code></pre>
<p>2、编写自定义SessionDao 继承EnterpriseCacheSessionDAO 重写读取Session的方法</p>
<pre><code class="language-Java">/**
 * 自定义SessionDAO从Redis中读取Session
 */
public class CustomSessionDAO extends EnterpriseCacheSessionDAO {
    @Override
    protected Session doReadSession(Serializable serializable) {
        return (Session) RedisUtil.get(serializable.toString());
    }
}
</code></pre>
<p>3、编写自定义SerssionListener 维护Session中的值</p>
<pre><code class="language-Java">/**
 * 自定义SerssionListener 维护Session中的值
 */
public class CustomSessionListener implements SessionListener {
    @Override
    public void onStart(Session session) {
        RedisUtil.set(session.getId().toString(),session);
    }

    @Override
    public void onStop(Session session) {
        RedisUtil.del(session.getId().toString());
    }

    @Override
    public void onExpiration(Session session) {
        RedisUtil.del(session.getId().toString());
    }
}

</code></pre>
<p>3、将CustomSessionDAO、CustomSerssionListener加入Shiro配置中</p>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/openapi/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setSessionManager(sessionManager);
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义SessionManager
     * @return
     */
    @Bean(&quot;sessionManager&quot;)
    public CustomWebSessionManager customWebSessionManager(SessionDAO sessionDAO){
        CustomWebSessionManager customWebSessionManager=new CustomWebSessionManager();
        customWebSessionManager.setSessionDAO(sessionDAO);
        //配置自定义
        List&lt;SessionListener&gt; listeners=new ArrayList&lt;&gt;();
        listeners.add(new CustomSessionListener());
        customWebSessionManager.setSessionListeners(listeners);
        return customWebSessionManager;
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }

    /**
     * 配置自定义SessionDAO
     * @return CustomSessionDAO
     */
    @Bean(&quot;sessionDAO&quot;)
    public CustomSessionDAO customSessionDao(){
        CustomSessionDAO customSessionDAO=new CustomSessionDAO();
        customSessionDAO.setSessionIdGenerator(new JavaUuidSessionIdGenerator());
        return customSessionDAO;
    }
}
</code></pre>
<h2 id="三-基于token的验证方式">三、基于Token的验证方式</h2>
<p>现如今，很多Web应用的验证方式都会采用基于token的验证方式，实际上这种方式很像我们上面所说的将SessionId放入请求头中，只是基于token的这种方式，token的保存的信息可能更具有意义。那在Shiro中如何来实现呢？<br>
1、登陆成功时，生成对应的token,并保存在redis中<br>
2、编写认证服务器,继承FormAuthenticationFilter,并重写onAccessDenied，从请求头中获取获取TOKEN，并从redis中获取token，对比token即可。</p>
<h2 id="四-统一认证中心">四、统一认证中心</h2>
<p>统一认证中心主要是进行统一的身份认证，主要是以下几个步骤：<br>
1、请求认证中心时，需要将验证后需要跳转的URL作为请求参数；<br>
2、服务端修改为不仅可以从Cookie和Header中获取对应的token或者sessionId，还需要可以从请求参数里获取到对应的值；<br>
3、服务端认证成功后将token或者sessionId作为参数重定向到登陆认证的回调地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 身份认证]]></title>
        <id>https://bofengsun.github.io//post/shiro-authentication</id>
        <link href="https://bofengsun.github.io//post/shiro-authentication">
        </link>
        <updated>2019-11-10T10:57:42.000Z</updated>
        <summary type="html"><![CDATA[<p>上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。</p>
<!-- more -->
<p>在上一节中我们看到Shiro的登陆，当时的用户信息是在配置文件中，但在实际项目中并不会这样，而是存储在数据库中那么，这种情况下Shiro又是怎样进行身份认证的呢？我们对上一章的代码做一个简单的修改，以了解认证的过程：<br>
依赖包：</p>
<pre><code class="language-XML">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--整合Shiro--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
            &lt;version&gt;1.4.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>前置代码：</p>
<pre><code class="language-Java">/**
 * 统一维护返回的数据
 */
public enum Result{
    //默认返回数据
    SUCCESS(0,&quot;请求成功！&quot;),
    FAILURE(500,&quot;请求失败！&quot;),
    //认证授权部分
    LOGIN_FAILURE(501,&quot;用户名或者密码错误！&quot;),
    LOGIN_FAILURE_LOCK(501,&quot;用户被锁定,请联系管理员！&quot;),
    LOGIN_FAILURE_RELOGIN(502,&quot;用户已经登陆,无须再次登陆！&quot;),
    AUTH_FAILURE(511,&quot;无权限！&quot;);

    private Integer code;
    private String msg;
    private Result(Integer code,String msg){
        this.code=code;
        this.msg=msg;
    }
    public Integer getCode() {
        return code;
    }
    public String getMsg() {
        return msg;
    }
}
/**
 * 统一返回的数据类型
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ResultVo&lt;T&gt; {
    private Integer code;
    private String msg;
    private T data;
    public static &lt;T&gt; ResultVo&lt;T&gt; success(T data){
        return new ResultVo&lt;&gt;(Result.SUCCESS.getCode(),Result.SUCCESS.getMsg(),data);
    }
    public static&lt;T&gt; ResultVo&lt;T&gt; failure(Result result){
        return new ResultVo&lt;&gt;(result.getCode(),result.getMsg(),null);
    }
}
</code></pre>
<p>Shiro的配置：Realm、SecurityManager、shiroFilter</p>
<ul>
<li>Relam:安全数据</li>
<li>SecurityManager： Shiro 的大管家负责组件协调</li>
<li>shiroFilter： Filter对哪些请求进行拦截</li>
</ul>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }
}
</code></pre>
<p>登陆认证部分的代码：</p>
<pre><code class="language-Java">/**
 * 认证控制器
 */
@RestController
@RequestMapping(&quot;/auth&quot;)
@Slf4j
public class AuthController {

    /**
     * 登陆
     * @param username 用户名
     * @param password 密码
     * @return 登陆结果
     */
    @PostMapping(&quot;/login&quot;)
    public ResultVo&lt;String&gt; login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password){
        Subject currentUser = SecurityUtils.getSubject();
        if (!currentUser.isAuthenticated()) {
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            try {
                currentUser.login(token);
                return ResultVo.success(currentUser.getSession().getId().toString());
            }catch (LockedAccountException lae) {
                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);
            }
            catch (AuthenticationException ae) {
                return ResultVo.failure(Result.LOGIN_FAILURE);
            }
        }else {
            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);
        }
    }
}
</code></pre>
<p>流程分析：<br>
1、先通过SecurityUtils#getSubject()获取当前用户<br>
2、Subject#isAuthenticated()调用判断当前用户是否登陆<br>
3、若没用进行登陆认证，则将用户的username和password为封装UsernamePasswordToken<br>
4、调用Subject#login(token)进行登陆<br>
5、通过自定义Realm进行身份认证，自定义Realm如果只是用来进行身份认证则只需继承org.apache.shiro.realm.AuthenticatingRealm即可，如果还需要进行鉴权，则需要继承org.apache.shiro.realm.AuthorizingRealm,这里我们就先继承AuthenticatingRealm。<br>
查看Realm的前置代码：</p>
<pre><code class="language-Java">/**
 * 用户实体信息
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class User {

    /**
     * 逻辑ID
     */
    private String id;
    /**
     * 用户名(唯一)
     */
    private String username;
    /**
     * 密码
     */
    private String password;
    /**
     * 状态是否锁定:1 是；0否
     */
    private Integer status;
}
/**
 * 用户服务
 */
public interface UserService {
    /**
     * 根据用户名获取用户
     * @param username 用户名
     * @return User
     */
    User getByUsername(String username);
}
@Service
public class UserServiceImpl implements UserService {
    /**
     * 初始化用户数据源
     */
    static final Map&lt;String,User&gt; USERS = new HashMap&lt;&gt;();
    static {
        USERS.put(&quot;admin&quot;,User.builder()
                .id(&quot;1&quot;)
                .username(&quot;admin&quot;)
                .password(&quot;123456&quot;)
                .status(0)
                .build());
        USERS.put(&quot;guest&quot;,User.builder()
                .id(&quot;2&quot;)
                .username(&quot;guest&quot;)
                .password(&quot;123456&quot;)
                .status(0)
                .build());
        USERS.put(&quot;lockeduser&quot;,User.builder()
                .id(&quot;2&quot;)
                .username(&quot;lockeduser&quot;)
                .password(&quot;123456&quot;)
                .status(1)
                .build());
    }

    @Override
    public User getByUsername(String username) {
        return USERS.get(username);
    }
}
/**
 * 常量类
 */
public interface Constant {
    /**
     * 用户被锁定状态
     */
    Integer USER_LOCKED=1;
}
/**
 * 自定义Realm
 */
@Slf4j
public class CustomRealm extends AuthenticatingRealm {

    @Autowired
    private UserService userService;

    /**
     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法
     * @param authenticationToken 令牌
     * @return 认证的信息
     * @throws AuthenticationException 认证异常
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        log.info(&quot;开始进行身份认证！&quot;);
        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;
        String username = usernamePasswordToken.getUsername();
        User user = userService.getByUsername(username);
        if(user==null){
            log.info(&quot;用户未找到！&quot;);
            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());
        }else if (Constant.USER_LOCKED.equals(user.getStatus())){
            log.info(&quot;用户被锁定！&quot;);
            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());
        }else {
            String principal=username;
            String credentials=user.getPassword();
            String realmName=getName();
            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,realmName);
            log.info(&quot;认证成功！&quot;);
            return simpleAuthenticationInfo;
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>