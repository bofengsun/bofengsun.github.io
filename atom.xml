<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bofengsun.github.io/</id>
    <title>玩命有人疼</title>
    <updated>2019-12-25T06:49:47.351Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bofengsun.github.io/"/>
    <link rel="self" href="https://bofengsun.github.io//atom.xml"/>
    <subtitle>重新开始，从心开始！</subtitle>
    <logo>https://bofengsun.github.io//images/avatar.png</logo>
    <icon>https://bofengsun.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 玩命有人疼</rights>
    <entry>
        <title type="html"><![CDATA[与你相遇恰似那一场梦]]></title>
        <id>https://bofengsun.github.io//post/yu-ni-xiang-yu-qia-si-na-yi-chang-meng</id>
        <link href="https://bofengsun.github.io//post/yu-ni-xiang-yu-qia-si-na-yi-chang-meng">
        </link>
        <updated>2019-12-25T06:30:19.000Z</updated>
        <summary type="html"><![CDATA[<p>我走在乡间的小路<br>
想起了往事篇篇<br>
你看</p>
]]></summary>
        <content type="html"><![CDATA[<p>我走在乡间的小路<br>
想起了往事篇篇<br>
你看</p>
<!-- more -->
<p>夏天，花丛，小道<br>
萍水相逢，你的笑容，便永驻我心间</p>
<p>我们一路走来<br>
爱使你我相遇相知相思相守<br>
你我在一起的两千多个日子<br>
夏冬与春秋，地北与天南<br>
萍踪靡定，我的心，永在你身边</p>
<p>那夜，梦到你出嫁<br>
一掀起盖头，我傻傻地看你，你娇羞地看我<br>
场面热闹，街坊邻里，拍手叫好<br>
梦醒，千里相思，想对你说，嫁我好吗？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Bean生命周期]]></title>
        <id>https://bofengsun.github.io//post/spring-bean-sheng-ming-zhou-qi</id>
        <link href="https://bofengsun.github.io//post/spring-bean-sheng-ming-zhou-qi">
        </link>
        <updated>2019-12-25T01:19:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring Boot Bean的生命周期，什么是Bean的生命周期，就是Bean从创建到销毁的过程。下面我们就看一看SpringBean的生命历程吧！</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring Boot Bean的生命周期，什么是Bean的生命周期，就是Bean从创建到销毁的过程。下面我们就看一看SpringBean的生命历程吧！</p>
<!-- more -->
<h1 id="bean的生命周期过程描述">Bean的生命周期过程描述</h1>
<p>我们先看一下Bean的生命周期过程中都会经历些什么，我先简单解释一下，后面我们通过源码进行详细解释。首先Spring在实例化Bean的时候，会先调用它的构造函数，进行Bean的实例化，然后进行Bean的初始化，Bean的初始化经过三个阶段初始化之前（<strong>applyBeanPostProcessorsBeforeInitialization</strong>），其次是进行初始化（<strong>invokeInitMethods</strong>），最后是初始化之后（<strong>postProcessAfterInitialization</strong>），这就是Bean的初始化过程；然后就开始利用Bean进行业务逻辑处理，最后容器正常关闭，Spring开始销毁Bean，Bean的销毁过程相对比较简单，调用**DisposableBeanAdapter.destroy()**方法，该方法中有三个地方比较重要，分别触发Bean的生命周期方法，它们是：<strong>processor.postProcessBeforeDestruction(this.bean, this.beanName);<br>
((DisposableBean) bean).destroy();<br>
invokeCustomDestroyMethod(this.destroyMethod);</strong><br>
下面我把用图片来进行直观展示：<br>
<img src="https://bofengsun.github.io//post-images/1577242534383.png" alt="Bean的生命周期.png"></p>
<h1 id="实例运行">实例运行</h1>
<p>User类，这里就是普通的一个Bean,用来添加到容器中，观察其生命周期</p>
<pre><code>package com.itbofeng.bean;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
public class User implements InitializingBean , DisposableBean {
    private String name;
    public User() {
        System.out.println(&quot;调用Bean的函数(constructor)&quot;);
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        System.out.println(&quot;调用Bean的函数(setName/setAttribute)&quot;);
        this.name = name;
    }
    @PostConstruct
    public void postConstruct(){
        System.out.println(&quot;调用Bean的函数(postConstruct)&quot;);
    }
    //MainConfig中@Bean 的initMethod
    public void initMethod(){
        System.out.println(&quot;调用Bean的函数(initMethod)&quot;);
    }
    //InitializingBean接口的方法afterPropertiesSet
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;调用Bean的函数(afterPropertiesSet)&quot;);
    }
    @PreDestroy
    public void preDestroy(){
        System.out.println(&quot;调用Bean的函数(preDestroy)&quot;);
    }
    //DisposableBean接口的方法destroy
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;调用Bean的函数(destroy)&quot;);
    }
    //MainConfig中@Bean 的destroyMethod
    public void destroyMethod(){
        System.out.println(&quot;调用Bean的函数(destroyMethod)&quot;);
    }
}
</code></pre>
<p>CustomBeanPostProcessor类，用来观察BeanPostProcessor的运行时期</p>
<pre><code>package com.itbofeng.bean;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.lang.Nullable;
import org.springframework.stereotype.Component;
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    @Nullable
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if(bean.getClass()==User.class){
            System.out.println(&quot;调用postProcessBeforeInitialization...&quot;);
        }
        return bean;
    }
    @Nullable
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if(bean.getClass()==User.class){
            System.out.println(&quot;调用postProcessAfterInitialization...&quot;);
        }
        return bean;
    }
}
</code></pre>
<p>MainConfig类，SpringBoot程序运行的主类，并将User和CustomBeanPostProcessor 加入到容器中</p>
<pre><code>package com.itbofeng;
import com.itbofeng.bean.User;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
@SpringBootApplication
public class MainConfig {
    public static void main(String[] args) {
        SpringApplication.run(MainConfig.class,args);
    }
    @Bean(initMethod = &quot;initMethod&quot;,destroyMethod = &quot;destroyMethod&quot;)
    public User user(){
        return new User();
    }
}
</code></pre>
<p>运行结果查看<br>
<img src="https://upload-images.jianshu.io/upload_images/8069900-af8e044c834478ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果.png"></p>
<h1 id="源码解析">源码解析</h1>
<p>初始化过程<br>
首先我们将断点打到CustomBeanPostProcessor.postProcessBeforeInitialization的第一行代码，然后我看一下其方法调用栈：<br>
![方法调用栈.png]<img src="https://bofengsun.github.io//post-images/1577242577818.png" alt=""><br>
主要包括两个地方，一个是容器刷新，第二个是初始化Bean，我们先对这容器刷新的源码进行简单查看</p>
<pre><code>public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
</code></pre>
<p>注意<strong>finishBeanFactoryInitialization</strong>，上面说明也解释说该方法的作用是初始化所有剩下的非懒加载的单例Bean,从该描述也可以知道，懒加载和原型的Bean在该阶段并不会被加载，这部分代码是Spring容器刷新时的代码，也是Spring IOC比较核心的代码，在学习后面中，慢慢将该部分的代码慢慢学习，接下来我们看一下初始化Bean部分的代码：</p>
<pre><code>protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
	//对实现了Aware接口的方法进行执行，方法就在下方，使用方法直接实现对应的Aware接口即可
	if (System.getSecurityManager() != null) {
		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
			invokeAwareMethods(beanName, bean);
			return null;
		}, getAccessControlContext());
	}
	else {
		invokeAwareMethods(beanName, bean);
	}

	Object wrappedBean = bean;
	if (mbd == null || !mbd.isSynthetic()) {
		//执行实现了BeanPostProcessor的postProcessBeforeInitialization方法
		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
	}

	try {
		//执行初始化方法
		invokeInitMethods(beanName, wrappedBean, mbd);
	}
	catch (Throwable ex) {
		throw new BeanCreationException(
				(mbd != null ? mbd.getResourceDescription() : null),
				beanName, &quot;Invocation of init method failed&quot;, ex);
	}
	if (mbd == null || !mbd.isSynthetic()) {
		//执行实现了BeanPostProcessor的postProcessAfterInitialization方法
		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
	}

	return wrappedBean;
}

private void invokeAwareMethods(final String beanName, final Object bean) {
	if (bean instanceof Aware) {
		if (bean instanceof BeanNameAware) {
			((BeanNameAware) bean).setBeanName(beanName);
		}
		if (bean instanceof BeanClassLoaderAware) {
			ClassLoader bcl = getBeanClassLoader();
			if (bcl != null) {
				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
			}
		}
		if (bean instanceof BeanFactoryAware) {
			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
		}
	}
}

protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)
			throws Throwable {

	boolean isInitializingBean = (bean instanceof InitializingBean);
	if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {
		if (logger.isDebugEnabled()) {
			logger.debug(&quot;Invoking afterPropertiesSet() on bean with name '&quot; + beanName + &quot;'&quot;);
		}
		//调用InitializingBean的afterPropertiesSet方法
		if (System.getSecurityManager() != null) {
			try {
				AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {
					((InitializingBean) bean).afterPropertiesSet();
					return null;
				}, getAccessControlContext());
			}
			catch (PrivilegedActionException pae) {
				throw pae.getException();
			}
		}
		else {
			((InitializingBean) bean).afterPropertiesSet();
		}
	}
	//调用@Bean制定的的initMethod方法
	if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {
		String initMethodName = mbd.getInitMethodName();
		if (StringUtils.hasLength(initMethodName) &amp;&amp;
				!(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;
				!mbd.isExternallyManagedInitMethod(initMethodName)) {
			invokeCustomInitMethod(beanName, bean, mbd);
		}
	}
}
</code></pre>
<p>以上就是初始化阶段，我们会发现初始化过程中没有@PostConstruct注解标注的方法，那是因为对@PostConstruct的处理也是BeanPostProcessor的实现类<strong>InitDestroyAnnotationBeanPostProcessor</strong>，那么我们就应该有疑问为什么InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction为什么会在CustomBeanPostProcessor.postProcessBeforeInitialization之后进行，是因为如果不指定顺序默认我们的getOrder为0，而InitDestroyAnnotationBeanPostProcessor的getOrder为Ordered.LOWEST_PRECEDENCE=2147483647,getOrder越大则，优先级越低，所以我们自定义的在其之前，至此初始化部分结束。<br>
下面我们简单看一下销毁阶段：</p>
<pre><code>public void destroy() {
	//处理@PreDestroy注解注释的方法
	if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {
		for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
			processor.postProcessBeforeDestruction(this.bean, this.beanName);
		}
	}
	//处理实现了DisposableBean接口的destroy的方法
	if (this.invokeDisposableBean) {
		if (logger.isDebugEnabled()) {
			logger.debug(&quot;Invoking destroy() on bean with name '&quot; + this.beanName + &quot;'&quot;);
		}
		try {
			if (System.getSecurityManager() != null) {
				AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {
					((DisposableBean) bean).destroy();
					return null;
				}, acc);
			}
			else {
				((DisposableBean) bean).destroy();
			}
		}
		catch (Throwable ex) {
			String msg = &quot;Invocation of destroy method failed on bean with name '&quot; + this.beanName + &quot;'&quot;;
			if (logger.isDebugEnabled()) {
				logger.warn(msg, ex);
			}
			else {
				logger.warn(msg + &quot;: &quot; + ex);
			}
		}
	}
	//处理@Bean指定的destroyMethod方法
	if (this.destroyMethod != null) {
		invokeCustomDestroyMethod(this.destroyMethod);
	}
	else if (this.destroyMethodName != null) {
		Method methodToCall = determineDestroyMethod(this.destroyMethodName);
		if (methodToCall != null) {
			invokeCustomDestroyMethod(methodToCall);
		}
	}
}
</code></pre>
<h1 id="结束语">结束语</h1>
<p>至此，我们Bean的生命周期探索初步结束，后面再做进一步深入学习，在学习本节课时要多进行调试，断点跟踪，会更加有效果。另外无论是在初始化还是在结束时都是处理的单例的Bean,而且在初始化时，处理的Bean还是非懒加载的，所以需要特殊说明：<strong>非懒加载的单实例Bean的生命周期如上;懒加载的单实例Bean是在第一次获取进行初始化过程;原型Bean是在每次获取时都进行初始化，而且Spring容器不会管理器销毁。</strong><br>
最近在网上看到了一篇文章，很不错，详细的介绍了Spring IOC的原理，如果大家想详细了解Spring的IOC可以看一下：https://www.cnblogs.com/ITtangtang/p/3978349.html，好东西大家一起分享，🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔫🏀⚽⚡👄🔥</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[相思相守]]></title>
        <id>https://bofengsun.github.io//post/xiang-si-xiang-shou</id>
        <link href="https://bofengsun.github.io//post/xiang-si-xiang-shou">
        </link>
        <updated>2019-12-16T05:51:45.000Z</updated>
        <summary type="html"><![CDATA[<p>长相思，长相思。若问相思甚了期，除非相见时。<br>
怕相思，已相思，轮到相思无处辞，眉间露一丝。</p>
<p>长相守，长相守，执子相守寄无期，但凭风雨处。<br>
念相守，寄相守，偕子相守深情处，怀中俯首时。</p>
]]></summary>
        <content type="html"><![CDATA[<p>长相思，长相思。若问相思甚了期，除非相见时。<br>
怕相思，已相思，轮到相思无处辞，眉间露一丝。</p>
<p>长相守，长相守，执子相守寄无期，但凭风雨处。<br>
念相守，寄相守，偕子相守深情处，怀中俯首时。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单点登陆（SSO）介绍]]></title>
        <id>https://bofengsun.github.io//post/dan-dian-deng-lu-ssojie-shao</id>
        <link href="https://bofengsun.github.io//post/dan-dian-deng-lu-ssojie-shao">
        </link>
        <updated>2019-11-26T05:23:34.000Z</updated>
        <summary type="html"><![CDATA[<p>单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。</p>
]]></summary>
        <content type="html"><![CDATA[<p>单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。</p>
<!-- more -->
<h2 id="1-产生背景">1、产生背景</h2>
<p>单点登陆的产生主要是随着企业业务的发展，企业会有许多系统来处理不通的业务，而如果各个系统均单独做登陆认证功能，会造成多个系统都需要开发一样的认证逻辑的功能，而且用户在使用时也需要频繁的进行登陆退回，而单点登陆，就是多个系统共同信任同一份票据，这份票据，可以在各个业务系统中进行使用，以此来实现身份认证的组合。</p>
<h2 id="2-实现流程">2、实现流程</h2>
<p>1、用户1登陆业务系统1<br>
2、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径1）<br>
3、用户没有登陆，跳转到登陆页面并携带（路径1）<br>
4、用户登陆，并保存凭据，重定向到（路径1），并携带凭据<br>
5、业务系统1 存储凭据<br>
6、用户2登陆业务系统2<br>
7、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径2）<br>
8、用户已登陆，重定向到（路径2），并携带凭据<br>
9、业务系统2，存储凭据</p>
<h2 id="3-客户端与服务器端的功能">3、客户端与服务器端的功能</h2>
<p>客户端：<br>
1、拦截子系统未登录用户请求，跳转至sso认证中心<br>
2、接收并存储sso认证中心发送的令牌<br>
3、与服务器端通信，校验令牌的有效性<br>
4、建立局部会话<br>
5、拦截用户注销请求，向sso认证中心发送注销请求<br>
服务器端：<br>
1、验证用户的登录信息<br>
2、创建全局会话<br>
3、创建授权令牌<br>
4、与客户端通信发送令牌<br>
6、校验客户端令牌有效性<br>
7、接收客户端注销请求，注销会话</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 密码加密与会话管理介绍]]></title>
        <id>https://bofengsun.github.io//post/shiro-mi-ma-jia-mi</id>
        <link href="https://bofengsun.github.io//post/shiro-mi-ma-jia-mi">
        </link>
        <updated>2019-11-14T15:54:05.000Z</updated>
        <summary type="html"><![CDATA[<p>密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。</p>
<!-- more -->
<h1 id="shiro-密码加密">Shiro 密码加密</h1>
<h2 id="0-前置代码后面用到以便理解">0、前置代码:后面用到，以便理解</h2>
<pre><code class="language-Java">    /**
     * 加密次数
     */
    Integer HASH_ITERATIONS=1024;
    /**
     * 加密算法
     */
    String HASH_ALGORITHMNAME=&quot;MD5&quot;;
</code></pre>
<h2 id="1-注册注册和认证时密码需要用同样的策略以保证密码密文的一致性">1、注册：注册和认证时密码需要用同样的策略，以保证密码密文的一致性。</h2>
<pre><code class="language-Java">    /**
     * 注册
     * @param registerVo
     * @return
     */
    @PostMapping(&quot;/register&quot;)
    public ResultVo&lt;Boolean&gt; register(@RequestBody LoginRegisterVo registerVo){
        //加密方式 可另行制定
        String algorithmName= Constant.HASH_ALGORITHMNAME;
        //密码明文
        Object source=registerVo.getPassword();
        //密码盐值 可另行制定
        Object salt=registerVo.getUsername();
        //加密次数 可另行制定
        int hashIterations=Constant.HASH_ITERATIONS;
        SimpleHash simpleHash = new SimpleHash(algorithmName, source, salt, hashIterations);
        //加密后密码
        String password = simpleHash.toHex();
        log.info(password);
        boolean flag=userService.addUser(registerVo.getUsername(),password);
        if(!flag){
            ResultVo.failure(Result.REGISTER_FAILURE);
        }
        return ResultVo.success(true);
    }
</code></pre>
<p>根据以上注册可生成密码，那么在登陆的时候，该如何进行匹配呢？下面我来看一下登录如何进行</p>
<h2 id="2-认证在进行用户认证dogetauthenticationinfo时需要指定盐值颜值需要唯一">2、认证：在进行用户认证(doGetAuthenticationInfo)时需要指定盐值，颜值需要唯一</h2>
<pre><code class="language-Java">    /**
     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法
     * @param authenticationToken 令牌
     * @return 认证的信息
     * @throws AuthenticationException 认证异常
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        log.info(&quot;开始进行身份认证！&quot;);
        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;
        String username = usernamePasswordToken.getUsername();
        User user = userService.getByUsername(username);
        if(user==null){
            log.info(&quot;用户未找到！&quot;);
            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());
        }else if (Constant.USER_LOCKED.equals(user.getStatus())){
            log.info(&quot;用户被锁定！&quot;);
            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());
        }else {
            Object principal=user.getId();
            String credentials=user.getPassword();
            String realmName=getName();
            //指定盐值
            ByteSource credentialsSalt = ByteSource.Util.bytes(usernamePasswordToken.getUsername());
            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,credentialsSalt,realmName);
            log.info(&quot;用户认证！&quot;);
            return simpleAuthenticationInfo;
        }
    }
</code></pre>
<h2 id="3-配置realm在realm密码策略以及加密次数">3、配置Realm:在Realm密码策略以及加密次数</h2>
<pre><code class="language-Java">    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(Constant.HASH_ALGORITHMNAME);
        credentialsMatcher.setHashIterations(Constant.HASH_ITERATIONS);
        customRealm.setCredentialsMatcher(credentialsMatcher);
        return customRealm;
    }
</code></pre>
<h2 id="4-扩展">4、扩展</h2>
<p>实际上Shiro支持多种密码策略，具体可以查看org.apache.shiro.authc.credential.CredentialsMatcher的子类</p>
<h1 id="shiro-会话管理">Shiro 会话管理</h1>
<h2 id="1-使用当前会话">1、使用当前会话</h2>
<pre><code class="language-Java">    SecurityUtils.getSubject().getSession();
</code></pre>
<h2 id="2-会话管理器sessionmanager管理session包括创建-维护-删除-失效-验证等工作">2、会话管理器(SessionManager):管理session包括创建、维护、删除、失效、验证等工作。</h2>
<pre><code class="language-Java">/**
 * 自定义SessionManager:从请求头中也可获取JSESSIONID
 */
@Slf4j
public class CustomWebSessionManager extends DefaultWebSessionManager{

    private static final String JSESSIONID=&quot;JSESSIONID&quot;;

    @Override
    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {
        Serializable id = super.getSessionId(request,response);
        //如果从Cookie中没有获取到SessionId,则从请求头中获取
        if (id == null) {
            id=WebUtils.toHttp(request).getHeader(JSESSIONID);
        }
        return id;
    }
}
</code></pre>
<h2 id="3-会话监听器sessionlistener监听会话状态触发对应的方法">3、会话监听器(SessionListener):监听会话状态，触发对应的方法</h2>
<pre><code class="language-Java">/**
 * 自定义SerssionListener 维护Session中的值
 */
public class CustomSessionListener implements SessionListener {
    @Override
    public void onStart(Session session) {
        RedisUtil.set(session.getId().toString(),session);
    }

    @Override
    public void onStop(Session session) {
        RedisUtil.del(session.getId().toString());
    }

    @Override
    public void onExpiration(Session session) {
        RedisUtil.del(session.getId().toString());
    }
}
</code></pre>
<h2 id="4-会话增删改查接口sessiondao">4、会话增删改查接口(SessionDAO)</h2>
<pre><code class="language-Java">public interface SessionDAO {
    Serializable create(Session var1);

    Session readSession(Serializable var1) throws UnknownSessionException;

    void update(Session var1) throws UnknownSessionException;

    void delete(Session var1);

    Collection&lt;Session&gt; getActiveSessions();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 权限认证]]></title>
        <id>https://bofengsun.github.io//post/shiro-quan-xian-ren-zheng</id>
        <link href="https://bofengsun.github.io//post/shiro-quan-xian-ren-zheng">
        </link>
        <updated>2019-11-13T04:39:28.000Z</updated>
        <summary type="html"><![CDATA[<p>前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。</p>
<!-- more -->
<h2 id="1-实现权限认证逻辑">1、实现权限认证逻辑</h2>
<p>基于前面的文章，自定义Realm继承AuthorizingRealm 需要实现doGetAuthenticationInfo 和 doGetAuthorizationInfo,其中doGetAuthenticationInfo主要用来身份认证，doGetAuthorizationInfo主要用来进行权限认证，具体代码如下：<br>
前置代码：</p>
<pre><code class="language-Java">    private static final Map&lt;String,Set&lt;String&gt;&gt; USER_ROLE= new HashMap&lt;&gt;();
    static {
        USER_ROLE.put(&quot;1&quot;,new HashSet&lt;&gt;(Arrays.asList(&quot;item:add&quot;,&quot;item:search&quot;,&quot;item:update&quot;,&quot;item:delete&quot;)));
        USER_ROLE.put(&quot;2&quot;,new HashSet&lt;&gt;(Arrays.asList(&quot;item:add&quot;,&quot;item:search&quot;)));
    }

    @Override
    public Set&lt;String&gt; getUserRoles(String userId) {
        Set&lt;String&gt; result = USER_ROLE.get(userId);
        return result!=null?result:Collections.EMPTY_SET;
    }
</code></pre>
<pre><code class="language-Java">    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        log.info(&quot;开始进行权限认证！&quot;);
        SimpleAuthorizationInfo simpleAuthorizationInfo=new SimpleAuthorizationInfo();
        String userId = (String)principalCollection.getPrimaryPrincipal();
        Set&lt;String&gt; userRoles = roleService.getUserRoles(userId);
        for (String userRole:userRoles){
            simpleAuthorizationInfo.addStringPermission(userRole);
        }
        return simpleAuthorizationInfo;
    }
</code></pre>
<h2 id="2-配置lifecyclebeanpostprocessor-defaultadvisorautoproxycreator-authorizationattributesourceadvisor">2、配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor</h2>
<p>因为Shiro需要对Controller进行代理，所以需要开启Controller的代理，需要配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor</p>
<pre><code class="language-Java">    @Bean
    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor(){
        return new LifecycleBeanPostProcessor();
    }
    @Bean
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator(){
        DefaultAdvisorAutoProxyCreator creator=new DefaultAdvisorAutoProxyCreator();
        creator.setProxyTargetClass(true);
        return creator;
    }
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor=new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }
</code></pre>
<h2 id="3-配置请求权限码">3、配置请求权限码</h2>
<p>通过注解配置权限信息，@RequiresRoles、@RequiresPermissions 以@RequiresPermissions为例：</p>
<pre><code class="language-Java">    @RequiresPermissions(&quot;item:search&quot;)
    @GetMapping(&quot;/search&quot;)
    public ResultVo&lt;String&gt; search(){
        return ResultVo.success(&quot;search&quot;);
    }
    @RequiresPermissions(&quot;item:add&quot;)
    @GetMapping(&quot;/add&quot;)
    public ResultVo&lt;String&gt; add(){
        return ResultVo.success(&quot;add&quot;);
    }
    @RequiresPermissions(&quot;item:update&quot;)
    @GetMapping(&quot;/update&quot;)
    public ResultVo&lt;String&gt; update(){
        return ResultVo.success(&quot;update&quot;);
    }
    @RequiresPermissions(&quot;item:delete&quot;)
    @GetMapping(&quot;/delete&quot;)
    public ResultVo&lt;String&gt; delete(){
        return ResultVo.success(&quot;delete&quot;);
    }
</code></pre>
<h2 id="4-演示效果">4、演示效果</h2>
<p>用户登陆：<br>
<img src="https://bofengsun.github.io//post-images/1573745823357.png" alt="登陆用户"><br>
有权限：<br>
<img src="https://bofengsun.github.io//post-images/1573745976892.png" alt="有权限"><br>
无权限：<br>
<img src="https://bofengsun.github.io//post-images/1573746081151.png" alt="无权限"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jmeter 体验之旅]]></title>
        <id>https://bofengsun.github.io//post/jmeter-ti-yan-zhi-lu</id>
        <link href="https://bofengsun.github.io//post/jmeter-ti-yan-zhi-lu">
        </link>
        <updated>2019-11-12T11:23:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。</p>
<!-- more -->
<h2 id="jmeter-介绍">Jmeter 介绍</h2>
<p>Apache JMeter 是一款开源的Java开发的用于进行软件性能测试的软件。</p>
<h2 id="安装和运行">安装和运行</h2>
<p>下载地址：http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-5.2.zip<br>
运行：windows环境： “bin/jmeter.bat”   linux环境： “bin/jmeter.sh”<br>
切换语言： 启动Jmeter 后， 点击 Options -&gt; Choose Language -&gt; Chinese[Simplified]  来选择简体中文<br>
截图如下：<br>
<img src="https://bofengsun.github.io//post-images/1573559262706.png" alt="Jmeter"></p>
<h2 id="案例">案例</h2>
<h3 id="添加默认设置">添加默认设置</h3>
<p>1、添加 HTTP Cookie管理器<br>
<img src="https://bofengsun.github.io//post-images/1573563560952.png" alt="HTTP Cookie管理器"><br>
2、添加 默认请求头<br>
<img src="https://bofengsun.github.io//post-images/1573563633762.png" alt="默认请求头"><br>
3、添加 默认请求<br>
<img src="https://bofengsun.github.io//post-images/1573563677239.png" alt="默认请求"></p>
<h3 id="添加线程组">添加线程组</h3>
<p>参数说明：<br>
线程数：表示需要启动的线程数量<br>
Ramp-Up时间：多少秒内启动这些线程，也就是说会在这个时间内启动这么多线程，如果设置为0，则表示同时启动<br>
循环次数：表示重复运行多少次，永远表示一直重复直到时间结束<br>
调度器配置：在配置调度器时生效，持续时间：就是执行多久<br>
<img src="https://bofengsun.github.io//post-images/1573563731549.png" alt="添加线程组"></p>
<h3 id="添加定时器">添加定时器</h3>
<figure data-type="image" tabindex="1"><img src="https://bofengsun.github.io//post-images/1573609185253.png" alt="添加定时器"></figure>
<h3 id="添加事务控制器">添加事务控制器</h3>
<figure data-type="image" tabindex="2"><img src="https://bofengsun.github.io//post-images/1573563817861.png" alt="事务控制器"></figure>
<h3 id="添加请求">添加请求</h3>
<figure data-type="image" tabindex="3"><img src="https://bofengsun.github.io//post-images/1573609251077.png" alt="添加请求"></figure>
<h3 id="添加断言">添加断言</h3>
<figure data-type="image" tabindex="4"><img src="https://bofengsun.github.io//post-images/1573609303540.png" alt="添加断言"></figure>
<h3 id="添加查看结果树">添加查看结果树</h3>
<figure data-type="image" tabindex="5"><img src="https://bofengsun.github.io//post-images/1573609390929.png" alt="添加查看结果树"></figure>
<h3 id="添加聚合报告">添加聚合报告</h3>
<figure data-type="image" tabindex="6"><img src="https://bofengsun.github.io//post-images/1573609486454.png" alt="添加聚合报告"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 身份认证（续）]]></title>
        <id>https://bofengsun.github.io//post/shiro-authentication-2</id>
        <link href="https://bofengsun.github.io//post/shiro-authentication-2">
        </link>
        <updated>2019-11-11T05:25:45.000Z</updated>
        <summary type="html"><![CDATA[<p>上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。</p>
<!-- more -->
<h2 id="一-如何和支持web-app-以及其他方式进行身份认证">一、如何和支持WEB、APP、以及其他方式进行身份认证？</h2>
<p>先回顾一下上一节我们的登陆部分代码：</p>
<pre><code class="language-Java">/**
 * 认证控制器
 */
@RestController
@RequestMapping(&quot;/auth&quot;)
@Slf4j
public class AuthController {

    /**
     * 登陆
     * @param username 用户名
     * @param password 密码
     * @return 登陆结果
     */
    @PostMapping(&quot;/login&quot;)
    public ResultVo&lt;String&gt; login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password){
        Subject currentUser = SecurityUtils.getSubject();
        if (!currentUser.isAuthenticated()) {
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            try {
                currentUser.login(token);
                return ResultVo.success(currentUser.getSession().getId().toString());
            }catch (LockedAccountException lae) {
                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);
            }
            catch (AuthenticationException ae) {
                return ResultVo.failure(Result.LOGIN_FAILURE);
            }
        }else {
            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);
        }
    }
}
</code></pre>
<p>可以看到我们在登陆成功后，把用户的SessionId返回给客户端，但在传统WEB其实是不需要的，因为在认证成功后会将SessionId保存在cookie里JSESSIONID，那么如果我们需要兼容APP或者其他方式这样就行不通，一种比较简单的方式就是我们把SessionId返回给客户端，客户端保存一份，每次请求时，将其作为请求头请求服务端，同时服务端也要改变获取SessionId的方式，不是从cookie里获取，而是从header里获取，这样就可以解决该问题，那么下面我们就看一下在Shiro中该如何做吧。<br>
1、自定义SessionManager继承DefaultWebSessionManager</p>
<pre><code class="language-Java">/**
 * 自定义SessionManager
 */
@Slf4j
public class CustomWebSessionManager extends DefaultWebSessionManager{

    private static final String JSESSIONID=&quot;JSESSIONID&quot;;

    @Override
    public Serializable getSessionId(SessionKey key) {
        Serializable id = super.getSessionId(key);
        //如果从Cookie中没有获取到SessionId,则从请求头中获取
        if (id == null) {
            HttpServletRequest request = (HttpServletRequest)WebUtils.getRequest(key);
            id = request.getHeader(JSESSIONID);
        }
        return id;
    }
}
</code></pre>
<p>2、将自定义的SessionManager放入容器中<br>
3、设置SecurityManager的SessionManager为自定义的SessionManager</p>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/openapi/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setSessionManager(sessionManager);
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义SessionManager
     * @return
     */
    @Bean(&quot;sessionManager&quot;)
    public CustomWebSessionManager customWebSessionManager(){
        return new CustomWebSessionManager();
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }
}
</code></pre>
<p>4、客户端登陆成功后将sessionId保存起来，每次请求的时候带上该请求头</p>
<h2 id="二-分布式环境下如何来维护session的呢">二、分布式环境下，如何来维护Session的呢？</h2>
<p>那么这里就是如何统一维护Session的问题了，我们一般会将Session保存在缓存中间件里，例如Redis，这样即保证性能，又实现功能，下面我们就体验一下吧？<br>
1、连接Redis以及编写RedisUtil（该部分仍是采用MAP进行处理，待后面和Redis继承时修改这里）</p>
<pre><code class="language-Java">/**
 * Redis工具类
 */
public class RedisUtil {
    static Map&lt;String,Object&gt; SESSION_ID_CACHE=new HashMap&lt;&gt;();
    public static void set(String key,Object value){
        SESSION_ID_CACHE.put(key,value);
    }
    public static Object get(String key){
        return SESSION_ID_CACHE.get(key);
    }
    public static void del(String key){
        SESSION_ID_CACHE.remove(key);
    }
    public static Collection values(){
        return SESSION_ID_CACHE.values();
    }
}
</code></pre>
<p>2、编写自定义SessionDao 继承EnterpriseCacheSessionDAO 重写读取Session的方法</p>
<pre><code class="language-Java">/**
 * 自定义SessionDAO从Redis中读取Session
 */
public class CustomSessionDAO extends EnterpriseCacheSessionDAO {
    @Override
    protected Session doReadSession(Serializable serializable) {
        return (Session) RedisUtil.get(serializable.toString());
    }
}
</code></pre>
<p>3、编写自定义SerssionListener 维护Session中的值</p>
<pre><code class="language-Java">/**
 * 自定义SerssionListener 维护Session中的值
 */
public class CustomSessionListener implements SessionListener {
    @Override
    public void onStart(Session session) {
        RedisUtil.set(session.getId().toString(),session);
    }

    @Override
    public void onStop(Session session) {
        RedisUtil.del(session.getId().toString());
    }

    @Override
    public void onExpiration(Session session) {
        RedisUtil.del(session.getId().toString());
    }
}

</code></pre>
<p>3、将CustomSessionDAO、CustomSerssionListener加入Shiro配置中</p>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/openapi/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setSessionManager(sessionManager);
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义SessionManager
     * @return
     */
    @Bean(&quot;sessionManager&quot;)
    public CustomWebSessionManager customWebSessionManager(SessionDAO sessionDAO){
        CustomWebSessionManager customWebSessionManager=new CustomWebSessionManager();
        customWebSessionManager.setSessionDAO(sessionDAO);
        //配置自定义
        List&lt;SessionListener&gt; listeners=new ArrayList&lt;&gt;();
        listeners.add(new CustomSessionListener());
        customWebSessionManager.setSessionListeners(listeners);
        return customWebSessionManager;
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }

    /**
     * 配置自定义SessionDAO
     * @return CustomSessionDAO
     */
    @Bean(&quot;sessionDAO&quot;)
    public CustomSessionDAO customSessionDao(){
        CustomSessionDAO customSessionDAO=new CustomSessionDAO();
        customSessionDAO.setSessionIdGenerator(new JavaUuidSessionIdGenerator());
        return customSessionDAO;
    }
}
</code></pre>
<h2 id="三-基于token的验证方式">三、基于Token的验证方式</h2>
<p>现如今，很多Web应用的验证方式都会采用基于token的验证方式，实际上这种方式很像我们上面所说的将SessionId放入请求头中，只是基于token的这种方式，token的保存的信息可能更具有意义。那在Shiro中如何来实现呢？<br>
1、登陆成功时，生成对应的token,并保存在redis中<br>
2、编写认证服务器,继承FormAuthenticationFilter,并重写onAccessDenied，从请求头中获取获取TOKEN，并从redis中获取token，对比token即可。</p>
<h2 id="四-统一认证中心">四、统一认证中心</h2>
<p>统一认证中心主要是进行统一的身份认证，主要是以下几个步骤：<br>
1、请求认证中心时，需要将验证后需要跳转的URL作为请求参数；<br>
2、服务端修改为不仅可以从Cookie和Header中获取对应的token或者sessionId，还需要可以从请求参数里获取到对应的值；<br>
3、服务端认证成功后将token或者sessionId作为参数重定向到登陆认证的回调地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 身份认证]]></title>
        <id>https://bofengsun.github.io//post/shiro-authentication</id>
        <link href="https://bofengsun.github.io//post/shiro-authentication">
        </link>
        <updated>2019-11-10T10:57:42.000Z</updated>
        <summary type="html"><![CDATA[<p>上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。</p>
<!-- more -->
<p>在上一节中我们看到Shiro的登陆，当时的用户信息是在配置文件中，但在实际项目中并不会这样，而是存储在数据库中那么，这种情况下Shiro又是怎样进行身份认证的呢？我们对上一章的代码做一个简单的修改，以了解认证的过程：<br>
依赖包：</p>
<pre><code class="language-XML">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--整合Shiro--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
            &lt;version&gt;1.4.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>前置代码：</p>
<pre><code class="language-Java">/**
 * 统一维护返回的数据
 */
public enum Result{
    //默认返回数据
    SUCCESS(0,&quot;请求成功！&quot;),
    FAILURE(500,&quot;请求失败！&quot;),
    //认证授权部分
    LOGIN_FAILURE(501,&quot;用户名或者密码错误！&quot;),
    LOGIN_FAILURE_LOCK(501,&quot;用户被锁定,请联系管理员！&quot;),
    LOGIN_FAILURE_RELOGIN(502,&quot;用户已经登陆,无须再次登陆！&quot;),
    AUTH_FAILURE(511,&quot;无权限！&quot;);

    private Integer code;
    private String msg;
    private Result(Integer code,String msg){
        this.code=code;
        this.msg=msg;
    }
    public Integer getCode() {
        return code;
    }
    public String getMsg() {
        return msg;
    }
}
/**
 * 统一返回的数据类型
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ResultVo&lt;T&gt; {
    private Integer code;
    private String msg;
    private T data;
    public static &lt;T&gt; ResultVo&lt;T&gt; success(T data){
        return new ResultVo&lt;&gt;(Result.SUCCESS.getCode(),Result.SUCCESS.getMsg(),data);
    }
    public static&lt;T&gt; ResultVo&lt;T&gt; failure(Result result){
        return new ResultVo&lt;&gt;(result.getCode(),result.getMsg(),null);
    }
}
</code></pre>
<p>Shiro的配置：Realm、SecurityManager、shiroFilter</p>
<ul>
<li>Relam:安全数据</li>
<li>SecurityManager： Shiro 的大管家负责组件协调</li>
<li>shiroFilter： Filter对哪些请求进行拦截</li>
</ul>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }
}
</code></pre>
<p>登陆认证部分的代码：</p>
<pre><code class="language-Java">/**
 * 认证控制器
 */
@RestController
@RequestMapping(&quot;/auth&quot;)
@Slf4j
public class AuthController {

    /**
     * 登陆
     * @param username 用户名
     * @param password 密码
     * @return 登陆结果
     */
    @PostMapping(&quot;/login&quot;)
    public ResultVo&lt;String&gt; login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password){
        Subject currentUser = SecurityUtils.getSubject();
        if (!currentUser.isAuthenticated()) {
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            try {
                currentUser.login(token);
                return ResultVo.success(currentUser.getSession().getId().toString());
            }catch (LockedAccountException lae) {
                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);
            }
            catch (AuthenticationException ae) {
                return ResultVo.failure(Result.LOGIN_FAILURE);
            }
        }else {
            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);
        }
    }
}
</code></pre>
<p>流程分析：<br>
1、先通过SecurityUtils#getSubject()获取当前用户<br>
2、Subject#isAuthenticated()调用判断当前用户是否登陆<br>
3、若没用进行登陆认证，则将用户的username和password为封装UsernamePasswordToken<br>
4、调用Subject#login(token)进行登陆<br>
5、通过自定义Realm进行身份认证，自定义Realm如果只是用来进行身份认证则只需继承org.apache.shiro.realm.AuthenticatingRealm即可，如果还需要进行鉴权，则需要继承org.apache.shiro.realm.AuthorizingRealm,这里我们就先继承AuthenticatingRealm。<br>
查看Realm的前置代码：</p>
<pre><code class="language-Java">/**
 * 用户实体信息
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class User {

    /**
     * 逻辑ID
     */
    private String id;
    /**
     * 用户名(唯一)
     */
    private String username;
    /**
     * 密码
     */
    private String password;
    /**
     * 状态是否锁定:1 是；0否
     */
    private Integer status;
}
/**
 * 用户服务
 */
public interface UserService {
    /**
     * 根据用户名获取用户
     * @param username 用户名
     * @return User
     */
    User getByUsername(String username);
}
@Service
public class UserServiceImpl implements UserService {
    /**
     * 初始化用户数据源
     */
    static final Map&lt;String,User&gt; USERS = new HashMap&lt;&gt;();
    static {
        USERS.put(&quot;admin&quot;,User.builder()
                .id(&quot;1&quot;)
                .username(&quot;admin&quot;)
                .password(&quot;123456&quot;)
                .status(0)
                .build());
        USERS.put(&quot;guest&quot;,User.builder()
                .id(&quot;2&quot;)
                .username(&quot;guest&quot;)
                .password(&quot;123456&quot;)
                .status(0)
                .build());
        USERS.put(&quot;lockeduser&quot;,User.builder()
                .id(&quot;2&quot;)
                .username(&quot;lockeduser&quot;)
                .password(&quot;123456&quot;)
                .status(1)
                .build());
    }

    @Override
    public User getByUsername(String username) {
        return USERS.get(username);
    }
}
/**
 * 常量类
 */
public interface Constant {
    /**
     * 用户被锁定状态
     */
    Integer USER_LOCKED=1;
}
/**
 * 自定义Realm
 */
@Slf4j
public class CustomRealm extends AuthenticatingRealm {

    @Autowired
    private UserService userService;

    /**
     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法
     * @param authenticationToken 令牌
     * @return 认证的信息
     * @throws AuthenticationException 认证异常
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        log.info(&quot;开始进行身份认证！&quot;);
        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;
        String username = usernamePasswordToken.getUsername();
        User user = userService.getByUsername(username);
        if(user==null){
            log.info(&quot;用户未找到！&quot;);
            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());
        }else if (Constant.USER_LOCKED.equals(user.getStatus())){
            log.info(&quot;用户被锁定！&quot;);
            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());
        }else {
            String principal=username;
            String credentials=user.getPassword();
            String realmName=getName();
            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,realmName);
            log.info(&quot;认证成功！&quot;);
            return simpleAuthenticationInfo;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 初体验]]></title>
        <id>https://bofengsun.github.io//post/shiro-01</id>
        <link href="https://bofengsun.github.io//post/shiro-01">
        </link>
        <updated>2019-11-08T09:39:44.000Z</updated>
        <summary type="html"><![CDATA[<p>Shiro 是一个Java安全框架，主要是进行身份认证，权限认证，密码加密，会话管理的一套框架，下面让我们一起来认识一下Shiro吧!</p>
]]></summary>
        <content type="html"><![CDATA[<p>Shiro 是一个Java安全框架，主要是进行身份认证，权限认证，密码加密，会话管理的一套框架，下面让我们一起来认识一下Shiro吧!</p>
<!-- more -->
<h2 id="1-认识shiro的功能">1、认识Shiro的功能</h2>
<p>看图说话，下图中是Shiro官网给出的描述，很明显主要包括四点：</p>
<ul>
<li>Authentication(身份认证)</li>
<li>Authorization(权限认证)</li>
<li>Session Management(会话管理)</li>
<li>Cryptography(密码学)<br>
<img src="https://bofengsun.github.io//post-images/1573123546063.png" alt="Shiro功能"></li>
</ul>
<h2 id="2-关键概念认识">2、关键概念认识</h2>
<ul>
<li>Subject (org.apache.shiro.subject.Subject) 主体<br>
指正在访问的主体，通常指当前用户，亦可指爬虫、定时任务等。</li>
<li>SecurityManager (org.apache.shiro.mgt.SecurityManager) 安全管理器<br>
安全管理器，是Shiro的核心，管理着所有的Subject，负责与Shiro的其他组件进行交互，类似与SpringMvc 中的DispatcherServlet。</li>
<li>Realms 安全数据<br>
主要是储存Shiro的安全数据（用户、角色、权限等），SecurityManager验证用户是否登陆、是否拥有权限等需要从其中获取数据。<br>
<img src="https://bofengsun.github.io//post-images/1573126718187.png" alt=""></li>
</ul>
<h2 id="3-初体验">3、初体验</h2>
<pre><code class="language-Java">//git clone https://github.com/apache/shiro.git 下载Shiro源码包括该代码。

public class Quickstart {

    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);


    public static void main(String[] args) {

        //用来从配置文件初始化Shiro环境，一般不会用
        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
        //获取当前用户,从这以后的代码都比较重要
        Subject currentUser = SecurityUtils.getSubject();
        //获取Session
        Session session = currentUser.getSession();
        session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);
        String value = (String) session.getAttribute(&quot;someKey&quot;);
        if (value.equals(&quot;aValue&quot;)) {
            log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);
        }

        // 判断用户是否经过身份认证，如果没用则进行身份认证
        if (!currentUser.isAuthenticated()) {
            //通过用户名密码进行登陆
            UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);   //设置记住我
            token.setRememberMe(true);
            try {
                //进行登陆
                currentUser.login(token);
            } catch (UnknownAccountException uae) {//用户不存在异常
                log.info(&quot;There is no user with username of &quot; + token.getPrincipal());
            } catch (IncorrectCredentialsException ice) {//密码不正确异常
                log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);
            } catch (LockedAccountException lae) {//用户被锁定异常
                log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +
                        &quot;Please contact your administrator to unlock it.&quot;);
            }
            // ... catch more exceptions here (maybe custom ones specific to your application?
            catch (AuthenticationException ae) {//认证异常，查看其子类发现Shiro提供的认证异常
                //unexpected condition?  error?
            }
        }

        log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);

        // 判断用户是否拥有角色
        if (currentUser.hasRole(&quot;schwartz&quot;)) {
            log.info(&quot;May the Schwartz be with you!&quot;);
        } else {
            log.info(&quot;Hello, mere mortal.&quot;);
        }

        //判断用户是否拥有权限
        //判断用户是否拥有winnebago:drive:eagle5权限
        //winnebago 类型，driver 行为，eagle5对象
        //如 当前用户拥有对张三（对象）这个用户（类型）的删除行为
        if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) {
            log.info(&quot;You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  &quot; +
                    &quot;Here are the keys - have fun!&quot;);
        } else {
            log.info(&quot;Sorry, you aren't allowed to drive the 'eagle5' winnebago!&quot;);
        }

        //用户退出登陆
        currentUser.logout();

        System.exit(0);
    }
}
</code></pre>
]]></content>
    </entry>
</feed>