<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bofengsun.github.io/</id>
    <title>玩命有人疼</title>
    <updated>2019-12-16T06:27:11.129Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bofengsun.github.io/"/>
    <link rel="self" href="https://bofengsun.github.io//atom.xml"/>
    <subtitle>重新开始，从心开始！</subtitle>
    <logo>https://bofengsun.github.io//images/avatar.png</logo>
    <icon>https://bofengsun.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 玩命有人疼</rights>
    <entry>
        <title type="html"><![CDATA[相思相守]]></title>
        <id>https://bofengsun.github.io//post/xiang-si-xiang-shou</id>
        <link href="https://bofengsun.github.io//post/xiang-si-xiang-shou">
        </link>
        <updated>2019-12-16T05:51:45.000Z</updated>
        <summary type="html"><![CDATA[<p>长相思，长相思。若问相思甚了期，除非相见时。<br>
怕相思，已相思，轮到相思无处辞，眉间露一丝。</p>
<p>长相守，长相守，执子相守寄无期，但凭风雨处。<br>
念相守，寄相守，偕子相守深情处，怀中俯首时。</p>
]]></summary>
        <content type="html"><![CDATA[<p>长相思，长相思。若问相思甚了期，除非相见时。<br>
怕相思，已相思，轮到相思无处辞，眉间露一丝。</p>
<p>长相守，长相守，执子相守寄无期，但凭风雨处。<br>
念相守，寄相守，偕子相守深情处，怀中俯首时。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单点登陆（SSO）介绍]]></title>
        <id>https://bofengsun.github.io//post/dan-dian-deng-lu-ssojie-shao</id>
        <link href="https://bofengsun.github.io//post/dan-dian-deng-lu-ssojie-shao">
        </link>
        <updated>2019-11-26T05:23:34.000Z</updated>
        <summary type="html"><![CDATA[<p>单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。</p>
]]></summary>
        <content type="html"><![CDATA[<p>单点登陆是很多企业进行企业项目整合都会用到的技术，单点登陆主要作用是简化用户认证流程，即登陆一次即可访问多个系统，退出一次全部退出。</p>
<!-- more -->
<h2 id="1-产生背景">1、产生背景</h2>
<p>单点登陆的产生主要是随着企业业务的发展，企业会有许多系统来处理不通的业务，而如果各个系统均单独做登陆认证功能，会造成多个系统都需要开发一样的认证逻辑的功能，而且用户在使用时也需要频繁的进行登陆退回，而单点登陆，就是多个系统共同信任同一份票据，这份票据，可以在各个业务系统中进行使用，以此来实现身份认证的组合。</p>
<h2 id="2-实现流程">2、实现流程</h2>
<p>1、用户1登陆业务系统1<br>
2、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径1）<br>
3、用户没有登陆，跳转到登陆页面并携带（路径1）<br>
4、用户登陆，并保存凭据，重定向到（路径1），并携带凭据<br>
5、业务系统1 存储凭据<br>
6、用户2登陆业务系统2<br>
7、检查没有携带凭据，让浏览器重定向SSO Server 登陆验证并携带自当前请求路径（路径2）<br>
8、用户已登陆，重定向到（路径2），并携带凭据<br>
9、业务系统2，存储凭据</p>
<h2 id="3-客户端与服务器端的功能">3、客户端与服务器端的功能</h2>
<p>客户端：<br>
1、拦截子系统未登录用户请求，跳转至sso认证中心<br>
2、接收并存储sso认证中心发送的令牌<br>
3、与服务器端通信，校验令牌的有效性<br>
4、建立局部会话<br>
5、拦截用户注销请求，向sso认证中心发送注销请求<br>
服务器端：<br>
1、验证用户的登录信息<br>
2、创建全局会话<br>
3、创建授权令牌<br>
4、与客户端通信发送令牌<br>
6、校验客户端令牌有效性<br>
7、接收客户端注销请求，注销会话</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 密码加密与会话管理介绍]]></title>
        <id>https://bofengsun.github.io//post/shiro-mi-ma-jia-mi</id>
        <link href="https://bofengsun.github.io//post/shiro-mi-ma-jia-mi">
        </link>
        <updated>2019-11-14T15:54:05.000Z</updated>
        <summary type="html"><![CDATA[<p>密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>密码加密主要是在用户登录与注册的时候进行的，用户在注册时生成密码，通过加密存储密文到数据库中，用户在登录时候，将前台用户填写的密码再次进行加密与数据库中的密码进行比对，一致即可通过；会话管理主要时类似Session、Token的生命周期，下面我们来简单认识一下Shiro的密码加密和会话管理。</p>
<!-- more -->
<h1 id="shiro-密码加密">Shiro 密码加密</h1>
<h2 id="0-前置代码后面用到以便理解">0、前置代码:后面用到，以便理解</h2>
<pre><code class="language-Java">    /**
     * 加密次数
     */
    Integer HASH_ITERATIONS=1024;
    /**
     * 加密算法
     */
    String HASH_ALGORITHMNAME=&quot;MD5&quot;;
</code></pre>
<h2 id="1-注册注册和认证时密码需要用同样的策略以保证密码密文的一致性">1、注册：注册和认证时密码需要用同样的策略，以保证密码密文的一致性。</h2>
<pre><code class="language-Java">    /**
     * 注册
     * @param registerVo
     * @return
     */
    @PostMapping(&quot;/register&quot;)
    public ResultVo&lt;Boolean&gt; register(@RequestBody LoginRegisterVo registerVo){
        //加密方式 可另行制定
        String algorithmName= Constant.HASH_ALGORITHMNAME;
        //密码明文
        Object source=registerVo.getPassword();
        //密码盐值 可另行制定
        Object salt=registerVo.getUsername();
        //加密次数 可另行制定
        int hashIterations=Constant.HASH_ITERATIONS;
        SimpleHash simpleHash = new SimpleHash(algorithmName, source, salt, hashIterations);
        //加密后密码
        String password = simpleHash.toHex();
        log.info(password);
        boolean flag=userService.addUser(registerVo.getUsername(),password);
        if(!flag){
            ResultVo.failure(Result.REGISTER_FAILURE);
        }
        return ResultVo.success(true);
    }
</code></pre>
<p>根据以上注册可生成密码，那么在登陆的时候，该如何进行匹配呢？下面我来看一下登录如何进行</p>
<h2 id="2-认证在进行用户认证dogetauthenticationinfo时需要指定盐值颜值需要唯一">2、认证：在进行用户认证(doGetAuthenticationInfo)时需要指定盐值，颜值需要唯一</h2>
<pre><code class="language-Java">    /**
     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法
     * @param authenticationToken 令牌
     * @return 认证的信息
     * @throws AuthenticationException 认证异常
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        log.info(&quot;开始进行身份认证！&quot;);
        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;
        String username = usernamePasswordToken.getUsername();
        User user = userService.getByUsername(username);
        if(user==null){
            log.info(&quot;用户未找到！&quot;);
            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());
        }else if (Constant.USER_LOCKED.equals(user.getStatus())){
            log.info(&quot;用户被锁定！&quot;);
            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());
        }else {
            Object principal=user.getId();
            String credentials=user.getPassword();
            String realmName=getName();
            //指定盐值
            ByteSource credentialsSalt = ByteSource.Util.bytes(usernamePasswordToken.getUsername());
            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,credentialsSalt,realmName);
            log.info(&quot;用户认证！&quot;);
            return simpleAuthenticationInfo;
        }
    }
</code></pre>
<h2 id="3-配置realm在realm密码策略以及加密次数">3、配置Realm:在Realm密码策略以及加密次数</h2>
<pre><code class="language-Java">    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(Constant.HASH_ALGORITHMNAME);
        credentialsMatcher.setHashIterations(Constant.HASH_ITERATIONS);
        customRealm.setCredentialsMatcher(credentialsMatcher);
        return customRealm;
    }
</code></pre>
<h2 id="4-扩展">4、扩展</h2>
<p>实际上Shiro支持多种密码策略，具体可以查看org.apache.shiro.authc.credential.CredentialsMatcher的子类</p>
<h1 id="shiro-会话管理">Shiro 会话管理</h1>
<h2 id="1-使用当前会话">1、使用当前会话</h2>
<pre><code class="language-Java">    SecurityUtils.getSubject().getSession();
</code></pre>
<h2 id="2-会话管理器sessionmanager管理session包括创建-维护-删除-失效-验证等工作">2、会话管理器(SessionManager):管理session包括创建、维护、删除、失效、验证等工作。</h2>
<pre><code class="language-Java">/**
 * 自定义SessionManager:从请求头中也可获取JSESSIONID
 */
@Slf4j
public class CustomWebSessionManager extends DefaultWebSessionManager{

    private static final String JSESSIONID=&quot;JSESSIONID&quot;;

    @Override
    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {
        Serializable id = super.getSessionId(request,response);
        //如果从Cookie中没有获取到SessionId,则从请求头中获取
        if (id == null) {
            id=WebUtils.toHttp(request).getHeader(JSESSIONID);
        }
        return id;
    }
}
</code></pre>
<h2 id="3-会话监听器sessionlistener监听会话状态触发对应的方法">3、会话监听器(SessionListener):监听会话状态，触发对应的方法</h2>
<pre><code class="language-Java">/**
 * 自定义SerssionListener 维护Session中的值
 */
public class CustomSessionListener implements SessionListener {
    @Override
    public void onStart(Session session) {
        RedisUtil.set(session.getId().toString(),session);
    }

    @Override
    public void onStop(Session session) {
        RedisUtil.del(session.getId().toString());
    }

    @Override
    public void onExpiration(Session session) {
        RedisUtil.del(session.getId().toString());
    }
}
</code></pre>
<h2 id="4-会话增删改查接口sessiondao">4、会话增删改查接口(SessionDAO)</h2>
<pre><code class="language-Java">public interface SessionDAO {
    Serializable create(Session var1);

    Session readSession(Serializable var1) throws UnknownSessionException;

    void update(Session var1) throws UnknownSessionException;

    void delete(Session var1);

    Collection&lt;Session&gt; getActiveSessions();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 权限认证]]></title>
        <id>https://bofengsun.github.io//post/shiro-quan-xian-ren-zheng</id>
        <link href="https://bofengsun.github.io//post/shiro-quan-xian-ren-zheng">
        </link>
        <updated>2019-11-13T04:39:28.000Z</updated>
        <summary type="html"><![CDATA[<p>前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前面几篇文章中我们提到Shiro的几个主要功能中，其中还包括了权限认证，那么这一节 我们就简单体验一下Shiro的权限认证吧。</p>
<!-- more -->
<h2 id="1-实现权限认证逻辑">1、实现权限认证逻辑</h2>
<p>基于前面的文章，自定义Realm继承AuthorizingRealm 需要实现doGetAuthenticationInfo 和 doGetAuthorizationInfo,其中doGetAuthenticationInfo主要用来身份认证，doGetAuthorizationInfo主要用来进行权限认证，具体代码如下：<br>
前置代码：</p>
<pre><code class="language-Java">    private static final Map&lt;String,Set&lt;String&gt;&gt; USER_ROLE= new HashMap&lt;&gt;();
    static {
        USER_ROLE.put(&quot;1&quot;,new HashSet&lt;&gt;(Arrays.asList(&quot;item:add&quot;,&quot;item:search&quot;,&quot;item:update&quot;,&quot;item:delete&quot;)));
        USER_ROLE.put(&quot;2&quot;,new HashSet&lt;&gt;(Arrays.asList(&quot;item:add&quot;,&quot;item:search&quot;)));
    }

    @Override
    public Set&lt;String&gt; getUserRoles(String userId) {
        Set&lt;String&gt; result = USER_ROLE.get(userId);
        return result!=null?result:Collections.EMPTY_SET;
    }
</code></pre>
<pre><code class="language-Java">    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        log.info(&quot;开始进行权限认证！&quot;);
        SimpleAuthorizationInfo simpleAuthorizationInfo=new SimpleAuthorizationInfo();
        String userId = (String)principalCollection.getPrimaryPrincipal();
        Set&lt;String&gt; userRoles = roleService.getUserRoles(userId);
        for (String userRole:userRoles){
            simpleAuthorizationInfo.addStringPermission(userRole);
        }
        return simpleAuthorizationInfo;
    }
</code></pre>
<h2 id="2-配置lifecyclebeanpostprocessor-defaultadvisorautoproxycreator-authorizationattributesourceadvisor">2、配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor</h2>
<p>因为Shiro需要对Controller进行代理，所以需要开启Controller的代理，需要配置LifecycleBeanPostProcessor、DefaultAdvisorAutoProxyCreator、AuthorizationAttributeSourceAdvisor</p>
<pre><code class="language-Java">    @Bean
    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor(){
        return new LifecycleBeanPostProcessor();
    }
    @Bean
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator(){
        DefaultAdvisorAutoProxyCreator creator=new DefaultAdvisorAutoProxyCreator();
        creator.setProxyTargetClass(true);
        return creator;
    }
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor=new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }
</code></pre>
<h2 id="3-配置请求权限码">3、配置请求权限码</h2>
<p>通过注解配置权限信息，@RequiresRoles、@RequiresPermissions 以@RequiresPermissions为例：</p>
<pre><code class="language-Java">    @RequiresPermissions(&quot;item:search&quot;)
    @GetMapping(&quot;/search&quot;)
    public ResultVo&lt;String&gt; search(){
        return ResultVo.success(&quot;search&quot;);
    }
    @RequiresPermissions(&quot;item:add&quot;)
    @GetMapping(&quot;/add&quot;)
    public ResultVo&lt;String&gt; add(){
        return ResultVo.success(&quot;add&quot;);
    }
    @RequiresPermissions(&quot;item:update&quot;)
    @GetMapping(&quot;/update&quot;)
    public ResultVo&lt;String&gt; update(){
        return ResultVo.success(&quot;update&quot;);
    }
    @RequiresPermissions(&quot;item:delete&quot;)
    @GetMapping(&quot;/delete&quot;)
    public ResultVo&lt;String&gt; delete(){
        return ResultVo.success(&quot;delete&quot;);
    }
</code></pre>
<h2 id="4-演示效果">4、演示效果</h2>
<p>用户登陆：<br>
<img src="https://bofengsun.github.io//post-images/1573745823357.png" alt="登陆用户"><br>
有权限：<br>
<img src="https://bofengsun.github.io//post-images/1573745976892.png" alt="有权限"><br>
无权限：<br>
<img src="https://bofengsun.github.io//post-images/1573746081151.png" alt="无权限"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jmeter 体验之旅]]></title>
        <id>https://bofengsun.github.io//post/jmeter-ti-yan-zhi-lu</id>
        <link href="https://bofengsun.github.io//post/jmeter-ti-yan-zhi-lu">
        </link>
        <updated>2019-11-12T11:23:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Jmeter 是一款测试工具，主要用来进行压力测试，今天和测试的同事在聊这个话题，顺便就体验了一下Jmeter进行压力测试，下面我就简单描述一下今天的体验吧。</p>
<!-- more -->
<h2 id="jmeter-介绍">Jmeter 介绍</h2>
<p>Apache JMeter 是一款开源的Java开发的用于进行软件性能测试的软件。</p>
<h2 id="安装和运行">安装和运行</h2>
<p>下载地址：http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-5.2.zip<br>
运行：windows环境： “bin/jmeter.bat”   linux环境： “bin/jmeter.sh”<br>
切换语言： 启动Jmeter 后， 点击 Options -&gt; Choose Language -&gt; Chinese[Simplified]  来选择简体中文<br>
截图如下：<br>
<img src="https://bofengsun.github.io//post-images/1573559262706.png" alt="Jmeter"></p>
<h2 id="案例">案例</h2>
<h3 id="添加默认设置">添加默认设置</h3>
<p>1、添加 HTTP Cookie管理器<br>
<img src="https://bofengsun.github.io//post-images/1573563560952.png" alt="HTTP Cookie管理器"><br>
2、添加 默认请求头<br>
<img src="https://bofengsun.github.io//post-images/1573563633762.png" alt="默认请求头"><br>
3、添加 默认请求<br>
<img src="https://bofengsun.github.io//post-images/1573563677239.png" alt="默认请求"></p>
<h3 id="添加线程组">添加线程组</h3>
<p>参数说明：<br>
线程数：表示需要启动的线程数量<br>
Ramp-Up时间：多少秒内启动这些线程，也就是说会在这个时间内启动这么多线程，如果设置为0，则表示同时启动<br>
循环次数：表示重复运行多少次，永远表示一直重复直到时间结束<br>
调度器配置：在配置调度器时生效，持续时间：就是执行多久<br>
<img src="https://bofengsun.github.io//post-images/1573563731549.png" alt="添加线程组"></p>
<h3 id="添加定时器">添加定时器</h3>
<figure data-type="image" tabindex="1"><img src="https://bofengsun.github.io//post-images/1573609185253.png" alt="添加定时器"></figure>
<h3 id="添加事务控制器">添加事务控制器</h3>
<figure data-type="image" tabindex="2"><img src="https://bofengsun.github.io//post-images/1573563817861.png" alt="事务控制器"></figure>
<h3 id="添加请求">添加请求</h3>
<figure data-type="image" tabindex="3"><img src="https://bofengsun.github.io//post-images/1573609251077.png" alt="添加请求"></figure>
<h3 id="添加断言">添加断言</h3>
<figure data-type="image" tabindex="4"><img src="https://bofengsun.github.io//post-images/1573609303540.png" alt="添加断言"></figure>
<h3 id="添加查看结果树">添加查看结果树</h3>
<figure data-type="image" tabindex="5"><img src="https://bofengsun.github.io//post-images/1573609390929.png" alt="添加查看结果树"></figure>
<h3 id="添加聚合报告">添加聚合报告</h3>
<figure data-type="image" tabindex="6"><img src="https://bofengsun.github.io//post-images/1573609486454.png" alt="添加聚合报告"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 身份认证（续）]]></title>
        <id>https://bofengsun.github.io//post/shiro-authentication-2</id>
        <link href="https://bofengsun.github.io//post/shiro-authentication-2">
        </link>
        <updated>2019-11-11T05:25:45.000Z</updated>
        <summary type="html"><![CDATA[<p>上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一节我们简单介绍了一下Shiro的身份认证，但其中有些细节之处我们没用讨论到，那么这一节中，我们就一些问题进行一下思考讨论。</p>
<!-- more -->
<h2 id="一-如何和支持web-app-以及其他方式进行身份认证">一、如何和支持WEB、APP、以及其他方式进行身份认证？</h2>
<p>先回顾一下上一节我们的登陆部分代码：</p>
<pre><code class="language-Java">/**
 * 认证控制器
 */
@RestController
@RequestMapping(&quot;/auth&quot;)
@Slf4j
public class AuthController {

    /**
     * 登陆
     * @param username 用户名
     * @param password 密码
     * @return 登陆结果
     */
    @PostMapping(&quot;/login&quot;)
    public ResultVo&lt;String&gt; login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password){
        Subject currentUser = SecurityUtils.getSubject();
        if (!currentUser.isAuthenticated()) {
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            try {
                currentUser.login(token);
                return ResultVo.success(currentUser.getSession().getId().toString());
            }catch (LockedAccountException lae) {
                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);
            }
            catch (AuthenticationException ae) {
                return ResultVo.failure(Result.LOGIN_FAILURE);
            }
        }else {
            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);
        }
    }
}
</code></pre>
<p>可以看到我们在登陆成功后，把用户的SessionId返回给客户端，但在传统WEB其实是不需要的，因为在认证成功后会将SessionId保存在cookie里JSESSIONID，那么如果我们需要兼容APP或者其他方式这样就行不通，一种比较简单的方式就是我们把SessionId返回给客户端，客户端保存一份，每次请求时，将其作为请求头请求服务端，同时服务端也要改变获取SessionId的方式，不是从cookie里获取，而是从header里获取，这样就可以解决该问题，那么下面我们就看一下在Shiro中该如何做吧。<br>
1、自定义SessionManager继承DefaultWebSessionManager</p>
<pre><code class="language-Java">/**
 * 自定义SessionManager
 */
@Slf4j
public class CustomWebSessionManager extends DefaultWebSessionManager{

    private static final String JSESSIONID=&quot;JSESSIONID&quot;;

    @Override
    public Serializable getSessionId(SessionKey key) {
        Serializable id = super.getSessionId(key);
        //如果从Cookie中没有获取到SessionId,则从请求头中获取
        if (id == null) {
            HttpServletRequest request = (HttpServletRequest)WebUtils.getRequest(key);
            id = request.getHeader(JSESSIONID);
        }
        return id;
    }
}
</code></pre>
<p>2、将自定义的SessionManager放入容器中<br>
3、设置SecurityManager的SessionManager为自定义的SessionManager</p>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/openapi/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setSessionManager(sessionManager);
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义SessionManager
     * @return
     */
    @Bean(&quot;sessionManager&quot;)
    public CustomWebSessionManager customWebSessionManager(){
        return new CustomWebSessionManager();
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }
}
</code></pre>
<p>4、客户端登陆成功后将sessionId保存起来，每次请求的时候带上该请求头</p>
<h2 id="二-分布式环境下如何来维护session的呢">二、分布式环境下，如何来维护Session的呢？</h2>
<p>那么这里就是如何统一维护Session的问题了，我们一般会将Session保存在缓存中间件里，例如Redis，这样即保证性能，又实现功能，下面我们就体验一下吧？<br>
1、连接Redis以及编写RedisUtil（该部分仍是采用MAP进行处理，待后面和Redis继承时修改这里）</p>
<pre><code class="language-Java">/**
 * Redis工具类
 */
public class RedisUtil {
    static Map&lt;String,Object&gt; SESSION_ID_CACHE=new HashMap&lt;&gt;();
    public static void set(String key,Object value){
        SESSION_ID_CACHE.put(key,value);
    }
    public static Object get(String key){
        return SESSION_ID_CACHE.get(key);
    }
    public static void del(String key){
        SESSION_ID_CACHE.remove(key);
    }
    public static Collection values(){
        return SESSION_ID_CACHE.values();
    }
}
</code></pre>
<p>2、编写自定义SessionDao 继承EnterpriseCacheSessionDAO 重写读取Session的方法</p>
<pre><code class="language-Java">/**
 * 自定义SessionDAO从Redis中读取Session
 */
public class CustomSessionDAO extends EnterpriseCacheSessionDAO {
    @Override
    protected Session doReadSession(Serializable serializable) {
        return (Session) RedisUtil.get(serializable.toString());
    }
}
</code></pre>
<p>3、编写自定义SerssionListener 维护Session中的值</p>
<pre><code class="language-Java">/**
 * 自定义SerssionListener 维护Session中的值
 */
public class CustomSessionListener implements SessionListener {
    @Override
    public void onStart(Session session) {
        RedisUtil.set(session.getId().toString(),session);
    }

    @Override
    public void onStop(Session session) {
        RedisUtil.del(session.getId().toString());
    }

    @Override
    public void onExpiration(Session session) {
        RedisUtil.del(session.getId().toString());
    }
}

</code></pre>
<p>3、将CustomSessionDAO、CustomSerssionListener加入Shiro配置中</p>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/openapi/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm, SessionManager sessionManager) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setSessionManager(sessionManager);
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义SessionManager
     * @return
     */
    @Bean(&quot;sessionManager&quot;)
    public CustomWebSessionManager customWebSessionManager(SessionDAO sessionDAO){
        CustomWebSessionManager customWebSessionManager=new CustomWebSessionManager();
        customWebSessionManager.setSessionDAO(sessionDAO);
        //配置自定义
        List&lt;SessionListener&gt; listeners=new ArrayList&lt;&gt;();
        listeners.add(new CustomSessionListener());
        customWebSessionManager.setSessionListeners(listeners);
        return customWebSessionManager;
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }

    /**
     * 配置自定义SessionDAO
     * @return CustomSessionDAO
     */
    @Bean(&quot;sessionDAO&quot;)
    public CustomSessionDAO customSessionDao(){
        CustomSessionDAO customSessionDAO=new CustomSessionDAO();
        customSessionDAO.setSessionIdGenerator(new JavaUuidSessionIdGenerator());
        return customSessionDAO;
    }
}
</code></pre>
<h2 id="三-基于token的验证方式">三、基于Token的验证方式</h2>
<p>现如今，很多Web应用的验证方式都会采用基于token的验证方式，实际上这种方式很像我们上面所说的将SessionId放入请求头中，只是基于token的这种方式，token的保存的信息可能更具有意义。那在Shiro中如何来实现呢？<br>
1、登陆成功时，生成对应的token,并保存在redis中<br>
2、编写认证服务器,继承FormAuthenticationFilter,并重写onAccessDenied，从请求头中获取获取TOKEN，并从redis中获取token，对比token即可。</p>
<h2 id="四-统一认证中心">四、统一认证中心</h2>
<p>统一认证中心主要是进行统一的身份认证，主要是以下几个步骤：<br>
1、请求认证中心时，需要将验证后需要跳转的URL作为请求参数；<br>
2、服务端修改为不仅可以从Cookie和Header中获取对应的token或者sessionId，还需要可以从请求参数里获取到对应的值；<br>
3、服务端认证成功后将token或者sessionId作为参数重定向到登陆认证的回调地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 身份认证]]></title>
        <id>https://bofengsun.github.io//post/shiro-authentication</id>
        <link href="https://bofengsun.github.io//post/shiro-authentication">
        </link>
        <updated>2019-11-10T10:57:42.000Z</updated>
        <summary type="html"><![CDATA[<p>上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一节 【Shiro 初体验】中我们认识了几个Shiro中重要的概念，以及一个QuickStart代码示例演示了Shiro的基本使用，也知道Shiro的几个主要功能，首先就是身份认证，那么下面我们就来看一下Shiro是如何进行身份认证的吧。</p>
<!-- more -->
<p>在上一节中我们看到Shiro的登陆，当时的用户信息是在配置文件中，但在实际项目中并不会这样，而是存储在数据库中那么，这种情况下Shiro又是怎样进行身份认证的呢？我们对上一章的代码做一个简单的修改，以了解认证的过程：<br>
依赖包：</p>
<pre><code class="language-XML">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--整合Shiro--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
            &lt;version&gt;1.4.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>前置代码：</p>
<pre><code class="language-Java">/**
 * 统一维护返回的数据
 */
public enum Result{
    //默认返回数据
    SUCCESS(0,&quot;请求成功！&quot;),
    FAILURE(500,&quot;请求失败！&quot;),
    //认证授权部分
    LOGIN_FAILURE(501,&quot;用户名或者密码错误！&quot;),
    LOGIN_FAILURE_LOCK(501,&quot;用户被锁定,请联系管理员！&quot;),
    LOGIN_FAILURE_RELOGIN(502,&quot;用户已经登陆,无须再次登陆！&quot;),
    AUTH_FAILURE(511,&quot;无权限！&quot;);

    private Integer code;
    private String msg;
    private Result(Integer code,String msg){
        this.code=code;
        this.msg=msg;
    }
    public Integer getCode() {
        return code;
    }
    public String getMsg() {
        return msg;
    }
}
/**
 * 统一返回的数据类型
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ResultVo&lt;T&gt; {
    private Integer code;
    private String msg;
    private T data;
    public static &lt;T&gt; ResultVo&lt;T&gt; success(T data){
        return new ResultVo&lt;&gt;(Result.SUCCESS.getCode(),Result.SUCCESS.getMsg(),data);
    }
    public static&lt;T&gt; ResultVo&lt;T&gt; failure(Result result){
        return new ResultVo&lt;&gt;(result.getCode(),result.getMsg(),null);
    }
}
</code></pre>
<p>Shiro的配置：Realm、SecurityManager、shiroFilter</p>
<ul>
<li>Relam:安全数据</li>
<li>SecurityManager： Shiro 的大管家负责组件协调</li>
<li>shiroFilter： Filter对哪些请求进行拦截</li>
</ul>
<pre><code class="language-Java">/**
 * Shiro 配置
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置ShiroFilter
     * @param securityManager 注入SecurityManager
     * @return ShiroFilterFactoryBean
     */
    @Bean(name = &quot;shiroFilter&quot;)
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMap.put(&quot;/auth/login&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }

    /**
     * 配置SecurityManager
     * @param customRealm 注入自定义Realm
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager(CustomRealm customRealm) {
        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();
        defaultSecurityManager.setRealm(customRealm);
        return defaultSecurityManager;
    }

    /**
     * 配置自定义的Realm
     * @return CustomRealm
     */
    @Bean
    public CustomRealm customRealm() {
        CustomRealm customRealm = new CustomRealm();
        return customRealm;
    }
}
</code></pre>
<p>登陆认证部分的代码：</p>
<pre><code class="language-Java">/**
 * 认证控制器
 */
@RestController
@RequestMapping(&quot;/auth&quot;)
@Slf4j
public class AuthController {

    /**
     * 登陆
     * @param username 用户名
     * @param password 密码
     * @return 登陆结果
     */
    @PostMapping(&quot;/login&quot;)
    public ResultVo&lt;String&gt; login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password){
        Subject currentUser = SecurityUtils.getSubject();
        if (!currentUser.isAuthenticated()) {
            UsernamePasswordToken token = new UsernamePasswordToken(username, password);
            try {
                currentUser.login(token);
                return ResultVo.success(currentUser.getSession().getId().toString());
            }catch (LockedAccountException lae) {
                return ResultVo.failure(Result.LOGIN_FAILURE_LOCK);
            }
            catch (AuthenticationException ae) {
                return ResultVo.failure(Result.LOGIN_FAILURE);
            }
        }else {
            return ResultVo.failure(Result.LOGIN_FAILURE_RELOGIN);
        }
    }
}
</code></pre>
<p>流程分析：<br>
1、先通过SecurityUtils#getSubject()获取当前用户<br>
2、Subject#isAuthenticated()调用判断当前用户是否登陆<br>
3、若没用进行登陆认证，则将用户的username和password为封装UsernamePasswordToken<br>
4、调用Subject#login(token)进行登陆<br>
5、通过自定义Realm进行身份认证，自定义Realm如果只是用来进行身份认证则只需继承org.apache.shiro.realm.AuthenticatingRealm即可，如果还需要进行鉴权，则需要继承org.apache.shiro.realm.AuthorizingRealm,这里我们就先继承AuthenticatingRealm。<br>
查看Realm的前置代码：</p>
<pre><code class="language-Java">/**
 * 用户实体信息
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class User {

    /**
     * 逻辑ID
     */
    private String id;
    /**
     * 用户名(唯一)
     */
    private String username;
    /**
     * 密码
     */
    private String password;
    /**
     * 状态是否锁定:1 是；0否
     */
    private Integer status;
}
/**
 * 用户服务
 */
public interface UserService {
    /**
     * 根据用户名获取用户
     * @param username 用户名
     * @return User
     */
    User getByUsername(String username);
}
@Service
public class UserServiceImpl implements UserService {
    /**
     * 初始化用户数据源
     */
    static final Map&lt;String,User&gt; USERS = new HashMap&lt;&gt;();
    static {
        USERS.put(&quot;admin&quot;,User.builder()
                .id(&quot;1&quot;)
                .username(&quot;admin&quot;)
                .password(&quot;123456&quot;)
                .status(0)
                .build());
        USERS.put(&quot;guest&quot;,User.builder()
                .id(&quot;2&quot;)
                .username(&quot;guest&quot;)
                .password(&quot;123456&quot;)
                .status(0)
                .build());
        USERS.put(&quot;lockeduser&quot;,User.builder()
                .id(&quot;2&quot;)
                .username(&quot;lockeduser&quot;)
                .password(&quot;123456&quot;)
                .status(1)
                .build());
    }

    @Override
    public User getByUsername(String username) {
        return USERS.get(username);
    }
}
/**
 * 常量类
 */
public interface Constant {
    /**
     * 用户被锁定状态
     */
    Integer USER_LOCKED=1;
}
/**
 * 自定义Realm
 */
@Slf4j
public class CustomRealm extends AuthenticatingRealm {

    @Autowired
    private UserService userService;

    /**
     * 实现该方法进行认证，在调用Subject#login的时候会进入该方法
     * @param authenticationToken 令牌
     * @return 认证的信息
     * @throws AuthenticationException 认证异常
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        log.info(&quot;开始进行身份认证！&quot;);
        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)authenticationToken;
        String username = usernamePasswordToken.getUsername();
        User user = userService.getByUsername(username);
        if(user==null){
            log.info(&quot;用户未找到！&quot;);
            throw new UnknownAccountException(Result.LOGIN_FAILURE.getMsg());
        }else if (Constant.USER_LOCKED.equals(user.getStatus())){
            log.info(&quot;用户被锁定！&quot;);
            throw new LockedAccountException(Result.LOGIN_FAILURE_LOCK.getMsg());
        }else {
            String principal=username;
            String credentials=user.getPassword();
            String realmName=getName();
            SimpleAuthenticationInfo simpleAuthenticationInfo=new SimpleAuthenticationInfo(principal,credentials,realmName);
            log.info(&quot;认证成功！&quot;);
            return simpleAuthenticationInfo;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro 初体验]]></title>
        <id>https://bofengsun.github.io//post/shiro-01</id>
        <link href="https://bofengsun.github.io//post/shiro-01">
        </link>
        <updated>2019-11-08T09:39:44.000Z</updated>
        <summary type="html"><![CDATA[<p>Shiro 是一个Java安全框架，主要是进行身份认证，权限认证，密码加密，会话管理的一套框架，下面让我们一起来认识一下Shiro吧!</p>
]]></summary>
        <content type="html"><![CDATA[<p>Shiro 是一个Java安全框架，主要是进行身份认证，权限认证，密码加密，会话管理的一套框架，下面让我们一起来认识一下Shiro吧!</p>
<!-- more -->
<h2 id="1-认识shiro的功能">1、认识Shiro的功能</h2>
<p>看图说话，下图中是Shiro官网给出的描述，很明显主要包括四点：</p>
<ul>
<li>Authentication(身份认证)</li>
<li>Authorization(权限认证)</li>
<li>Session Management(会话管理)</li>
<li>Cryptography(密码学)<br>
<img src="https://bofengsun.github.io//post-images/1573123546063.png" alt="Shiro功能"></li>
</ul>
<h2 id="2-关键概念认识">2、关键概念认识</h2>
<ul>
<li>Subject (org.apache.shiro.subject.Subject) 主体<br>
指正在访问的主体，通常指当前用户，亦可指爬虫、定时任务等。</li>
<li>SecurityManager (org.apache.shiro.mgt.SecurityManager) 安全管理器<br>
安全管理器，是Shiro的核心，管理着所有的Subject，负责与Shiro的其他组件进行交互，类似与SpringMvc 中的DispatcherServlet。</li>
<li>Realms 安全数据<br>
主要是储存Shiro的安全数据（用户、角色、权限等），SecurityManager验证用户是否登陆、是否拥有权限等需要从其中获取数据。<br>
<img src="https://bofengsun.github.io//post-images/1573126718187.png" alt=""></li>
</ul>
<h2 id="3-初体验">3、初体验</h2>
<pre><code class="language-Java">//git clone https://github.com/apache/shiro.git 下载Shiro源码包括该代码。

public class Quickstart {

    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);


    public static void main(String[] args) {

        //用来从配置文件初始化Shiro环境，一般不会用
        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
        //获取当前用户,从这以后的代码都比较重要
        Subject currentUser = SecurityUtils.getSubject();
        //获取Session
        Session session = currentUser.getSession();
        session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);
        String value = (String) session.getAttribute(&quot;someKey&quot;);
        if (value.equals(&quot;aValue&quot;)) {
            log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);
        }

        // 判断用户是否经过身份认证，如果没用则进行身份认证
        if (!currentUser.isAuthenticated()) {
            //通过用户名密码进行登陆
            UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);   //设置记住我
            token.setRememberMe(true);
            try {
                //进行登陆
                currentUser.login(token);
            } catch (UnknownAccountException uae) {//用户不存在异常
                log.info(&quot;There is no user with username of &quot; + token.getPrincipal());
            } catch (IncorrectCredentialsException ice) {//密码不正确异常
                log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);
            } catch (LockedAccountException lae) {//用户被锁定异常
                log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +
                        &quot;Please contact your administrator to unlock it.&quot;);
            }
            // ... catch more exceptions here (maybe custom ones specific to your application?
            catch (AuthenticationException ae) {//认证异常，查看其子类发现Shiro提供的认证异常
                //unexpected condition?  error?
            }
        }

        log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);

        // 判断用户是否拥有角色
        if (currentUser.hasRole(&quot;schwartz&quot;)) {
            log.info(&quot;May the Schwartz be with you!&quot;);
        } else {
            log.info(&quot;Hello, mere mortal.&quot;);
        }

        //判断用户是否拥有权限
        //判断用户是否拥有winnebago:drive:eagle5权限
        //winnebago 类型，driver 行为，eagle5对象
        //如 当前用户拥有对张三（对象）这个用户（类型）的删除行为
        if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) {
            log.info(&quot;You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  &quot; +
                    &quot;Here are the keys - have fun!&quot;);
        } else {
            log.info(&quot;Sorry, you aren't allowed to drive the 'eagle5' winnebago!&quot;);
        }

        //用户退出登陆
        currentUser.logout();

        System.exit(0);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础知识]]></title>
        <id>https://bofengsun.github.io//post/java-ji-chu-zhi-shi</id>
        <link href="https://bofengsun.github.io//post/java-ji-chu-zhi-shi">
        </link>
        <updated>2019-11-07T08:05:09.000Z</updated>
        <summary type="html"><![CDATA[<p>万丈高楼平地起，掌握并牢记基础知识，是学习后面知识的根基，下面我们一起回顾一下Java的基础知识吧！</p>
]]></summary>
        <content type="html"><![CDATA[<p>万丈高楼平地起，掌握并牢记基础知识，是学习后面知识的根基，下面我们一起回顾一下Java的基础知识吧！</p>
<!-- more -->
<h2 id="一-基础部分">一、基础部分</h2>
<h3 id="1-基本数据类型8中">1、基本数据类型8中</h3>
<pre><code class="language-JAVA">四种整数型：byte(8)、short(16)、int(32)、long(64)

二种浮点型：float(32)、double(64)

一种字符型：char(16)

一种布尔型：boolean
</code></pre>
<h3 id="2-object类常用方法">2、Object类常用方法</h3>
<pre><code class="language-java">Equals
Hashcode
toString
wait
notify
notifyAll
clone
getClass
finalize
</code></pre>
<h3 id="3-值传递-引用传递">3、值传递、引用传递</h3>
<p>Java中是值传递，对于基本数据类型，传递的是值的副本，对于引用类型传递的是对象地址的副本。</p>
<pre><code class="language-java">package com.itbofeng;

public class TestValuePassRefPass {
    public static void main(String[] args) {
        int i=100;
        String str=&quot;aa&quot;;
        changeInt(i);
        changeString(str);
        System.out.println(i);//100
        System.out.println(str);//aa
    }
    private static void changeInt(int i) {
        i=0;
    }
    private static void changeString(String str) {
        str=&quot;bb&quot;;
    }
}
</code></pre>
<h3 id="4-数组实例化">4、数组实例化</h3>
<pre><code class="language-JAVA">1、数组一旦实例化，它的长度就是固定的

2、静态实例化:```java int[] a=new int[]{1,3,3}``` , ```java int[] a={1,3,3}```
   动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值

3、数组反序
  1、将原数组中的元素进行逆序（原数组改变，占用内存小）
  public void arrayReverse() {
        int []originArray={1,2,3,4,5}
        int temp = 0;
        for (int i = 0; i &lt; length / 2; i++) {
            temp = originArray[i];
            originArray[i] = originArray[length - i - 1];
            originArray[length - i - 1] = temp;
        }
  }
  2、创建新数组逆序存储原数组元素（原数组不变，占用内存大）
  public void arrayReverse() {
        int []originArray={1,2,3,4,5}
        int length=originArray.length;
        int []reverseArray = new int[length];
        for (int i = 0; i &lt; length; i++) {
            reverseArray[i] = originArray[length - i - 1];
        }
  }
</code></pre>
<h3 id="5-和的区别-和的区别">5、&amp;和&amp;&amp;的区别 、|和||的区别</h3>
<pre><code class="language-java">	&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。
	&amp;&amp;具有短路的功能,&amp;不具备短路的功能
	|和||都可以用作逻辑或的运算符，表示逻辑或（or），当运算符两边的表达式的结果有一个为true时，整个运算结果才为true，否则，只有全部为false，则结果为false。
	||具有短路的功能,|不具备短路的功能
</code></pre>
<h3 id="6-string和stringbuilderstringbuffer的区别">6、String和StringBuilder，StringBuffer的区别</h3>
<pre><code class="language-Java">	1、String对象不可变，因此在进⾏任何内容上的修改时都会创建新的字符串对象，修改操作太多造成资源浪费。
    2、StringBuilder和StringBuffer修改字符串不是创建新的对象，而是在原对象上面进行修改。
    3、StringBuffer线程安全的是 StringBuilder是线程不安全的，StringBuilder效率比StringBuffer高。
</code></pre>
<h3 id="7-hashmap-hashtable-concurrenthashmap-的区别">7、HashMap、HashTable、 ConcurrentHashMap 的区别</h3>
<pre><code class="language-Java">    1、HashMap不是线程安全的、HashTable、ConcurrentHashMap是线程安全的。
    2、HashTable是synchronized锁定方法，在高并发环境下效率比较低，ConcurrentHashMap采用分段锁，从而增加并发性能。
    备注：在源码讲解中会分别对HashMap、HashTable、ConcurrentHashMap进行讲解。
</code></pre>
<h3 id="8-switch-语法">8、switch 语法</h3>
<pre><code class="language-java">    1、在switch（exp）中，exp只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的
    2、从Java SE 7开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。
    3、Long、Double不支持 非整数表达式或者枚举常量以及字符串
</code></pre>
<h3 id="9-大数计算思路">9、大数计算思路</h3>
<pre><code class="language-java">	考点：
        1、计算机原理
        2、计算机中的算术运算会发生越界的情况
        3、具备一定的面向对象的设计思想
    思路：
        1、计算机原理（原码、反码、补码）
        2、面向对象设计
    实现：
        1、这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数
        2、有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中
        3、提供加减乘除的功能
    代码：
        public class BigInteger{
            byte sign;
            byte[] val;
            public Biginteger(String val)	{
                sign =a ;
                val = ;
            }
            public BigInteger add(BigInteger other)	{

            }
            public BigInteger subtract(BigInteger other)	{

            }
            public BigInteger multiply(BigInteger other){

            }
            public BigInteger divide(BigInteger other){

            }
        }

</code></pre>
<h3 id="10-和equals方法">10、&quot;==&quot;和equals方法</h3>
<pre><code class="language-java">	1、对于引用类型，涉及了两块内存，对象本身占用一块内存（堆），变量也占用一块内存（栈），例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。
	2、==
      ==操作符专门用来比较基本数据类型的值是否相等，以及引用类型的变量地址是否相等，即比较栈中值是否相等
    3、equals
      equals方法是Java Object类中的方法，在Object类中equals的实现是等同于==，如果一个对象没有重写equals方法，那么此时equals方法等同于==，但是在许多对象比较中，例如字符串，我们实际需要比较的对象的值是否相等，而不是变量的值是否相等，那么此时需要重写equals
</code></pre>
<h3 id="11-基本数据类型和包装类型的区别">11、基本数据类型和包装类型的区别</h3>
<pre><code class="language-Java">    1、基本类型和包装类型的默认值不同，基本类型有自己的默认值，包装类型默认值是null
    2、基本类型==比较的是值，包装类型==比较的是变量地址
    3、包装类型提供了很多其他的方法
</code></pre>
<h3 id="12-作用域publicprivateprotected以及不写时friendly区别">12、作用域public，private，protected，以及不写时（friendly）区别</h3>
<table>
<thead>
<tr>
<th style="text-align:center">作用域</th>
<th style="text-align:center">当前类</th>
<th style="text-align:center">同一包</th>
<th style="text-align:center">子孙类</th>
<th style="text-align:center">其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">friendly</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h3 id="13-静态变量和实例变量的区别">13、静态变量和实例变量的区别</h3>
<pre><code class="language-Java">    1、在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加
    2、在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
</code></pre>
<h3 id="14-重载overload重写override">14、重载(Overload)&amp;重写（Override）</h3>
<pre><code class="language-JAVA">    1、重载：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
    2、重写：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。
</code></pre>
<h3 id="15-continue-break">15、continue &amp;  break</h3>
<pre><code class="language-JAVA">    1、continue:在循环语句中,它会中断正常的控制流程，跳出当次循环,然后继续下一次循环；
    2、break：可用在循环,判断等语句中,用于退出当前语句，在循环语句中就是退出当前循环；
</code></pre>
<h3 id="16-final-关键字">16、final 关键字</h3>
<h3 id="17-this-关键字">17、this 关键字</h3>
<h3 id="18-transient-关键字">18、transient 关键字</h3>
<h3 id="19-instanceof-关键字">19、instanceof 关键字</h3>
<h3 id="20-字符型常量和字符串常量的区别">20、字符型常量和字符串常量的区别</h3>
<h3 id="21-成员变量与局部变量的区别有那些">21、成员变量与局部变量的区别有那些</h3>
<h3 id="22-自动拆箱装箱">22、自动拆箱装箱</h3>
<h3 id="23-接口抽象类">23、接口&amp;抽象类</h3>
<h3 id="24-java-引用">24、Java 引用</h3>
<h3 id="25-hashcodeequals">25、hashCode&amp;equals</h3>
<h3 id="26-comparable和comparator">26、Comparable和Comparator</h3>
<h2 id="二-面向对象部分">二、面向对象部分</h2>
<h2 id="三-web相关部分">三、WEB相关部分</h2>
<p>❤️❤️❤️未完待续❤️❤️❤️</p>
]]></content>
    </entry>
</feed>